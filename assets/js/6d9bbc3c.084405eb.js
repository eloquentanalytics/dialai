"use strict";(globalThis.webpackChunkdialai_website=globalThis.webpackChunkdialai_website||[]).push([[5831],{3392(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"guides/implementing-strategies","title":"Implementing Strategies","description":"Strategies are async functions that define how specialists make decisions. Each specialist is registered with a strategyFn that gets called during the decision cycle.","source":"@site/docs/guides/implementing-strategies.md","sourceDirName":"guides","slug":"/guides/implementing-strategies","permalink":"/dialai/docs/guides/implementing-strategies","draft":false,"unlisted":false,"editUrl":"https://github.com/eloquentanalytics/dialai/tree/main/website/docs/guides/implementing-strategies.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Registering Specialists","permalink":"/dialai/docs/guides/registering-specialists"},"next":{"title":"API Reference","permalink":"/dialai/docs/api/intro"}}');var r=n(4848),i=n(8453);const a={sidebar_position:3},o="Implementing Strategies",c={},l=[{value:"Proposer Strategy",id:"proposer-strategy",level:2},{value:"Proposer strategyFn Signature",id:"proposer-strategyfn-signature",level:3},{value:"Example: Pick the First Transition",id:"example-pick-the-first-transition",level:3},{value:"Example: Goal-Directed Proposer",id:"example-goal-directed-proposer",level:3},{value:"Voter Strategy",id:"voter-strategy",level:2},{value:"Voter strategyFn Signature",id:"voter-strategyfn-signature",level:3},{value:"Example: Prefer Goal-Reaching Proposals",id:"example-prefer-goal-reaching-proposals",level:3},{value:"Arbiter Strategy",id:"arbiter-strategy",level:2},{value:"Arbiter strategyFn Signature",id:"arbiter-strategyfn-signature",level:3},{value:"Using Strategies with Specialists",id:"using-strategies-with-specialists",level:2},{value:"Direct Submission",id:"direct-submission",level:2}];function p(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"implementing-strategies",children:"Implementing Strategies"})}),"\n",(0,r.jsxs)(t.p,{children:["Strategies are async functions that define how specialists make decisions. Each specialist is registered with a ",(0,r.jsx)(t.code,{children:"strategyFn"})," that gets called during the decision cycle."]}),"\n",(0,r.jsx)(t.h2,{id:"proposer-strategy",children:"Proposer Strategy"}),"\n",(0,r.jsxs)(t.p,{children:["A proposer ",(0,r.jsx)(t.code,{children:"strategyFn"})," receives a ",(0,r.jsx)(t.code,{children:"ProposerContext"})," and returns a transition choice:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'const myProposer = async (ctx: ProposerContext) => {\n  // ctx.currentState: string - the session\'s current state name\n  // ctx.prompt: string - the decision prompt from the state definition\n  // ctx.transitions: Record<string, string> - maps transition name to target state\n  // ctx.history: TransitionRecord[] - prior transitions in this session\n\n  // Your logic here: call an LLM, apply rules, etc.\n\n  return {\n    transitionName: "complete",\n    toState: "done",\n    reasoning: "Task is ready to be completed",\n  };\n};\n'})}),"\n",(0,r.jsx)(t.h3,{id:"proposer-strategyfn-signature",children:"Proposer strategyFn Signature"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"strategyFn: async (ctx: ProposerContext) => {\n  transitionName: string;\n  toState: string;\n  reasoning: string;\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"example-pick-the-first-transition",children:"Example: Pick the First Transition"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'const firstTransition = async (ctx: ProposerContext) => {\n  const name = Object.keys(ctx.transitions)[0];\n  return {\n    transitionName: name,\n    toState: ctx.transitions[name],\n    reasoning: "First available transition",\n  };\n};\n'})}),"\n",(0,r.jsx)(t.h3,{id:"example-goal-directed-proposer",children:"Example: Goal-Directed Proposer"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'const goalDirected = async (ctx: ProposerContext) => {\n  // Prefer transitions that lead to the goal state\n  for (const [name, target] of Object.entries(ctx.transitions)) {\n    if (target === "done" || target === "approved" || target === "completed") {\n      return {\n        transitionName: name,\n        toState: target,\n        reasoning: `Transition "${name}" leads directly to goal state "${target}"`,\n      };\n    }\n  }\n  // Fallback to first transition\n  const name = Object.keys(ctx.transitions)[0];\n  return {\n    transitionName: name,\n    toState: ctx.transitions[name],\n    reasoning: "No direct path to goal; taking first available transition",\n  };\n};\n'})}),"\n",(0,r.jsx)(t.h2,{id:"voter-strategy",children:"Voter Strategy"}),"\n",(0,r.jsxs)(t.p,{children:["A voter ",(0,r.jsx)(t.code,{children:"strategyFn"})," receives a ",(0,r.jsx)(t.code,{children:"VoterContext"})," and returns a preference:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'const myVoter = async (ctx: VoterContext) => {\n  // ctx.proposalA, ctx.proposalB: Proposal objects with:\n  //   proposalId, sessionId, specialistId, transitionName, toState, reasoning\n  // ctx.currentState: string\n  // ctx.prompt: string\n  // ctx.history: TransitionRecord[]\n\n  // Your logic to compare proposals\n\n  return {\n    voteFor: "A", // "A" | "B" | "BOTH" | "NEITHER"\n    reasoning: "Proposal A better aligns with the decision criteria",\n  };\n};\n'})}),"\n",(0,r.jsx)(t.h3,{id:"voter-strategyfn-signature",children:"Voter strategyFn Signature"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'strategyFn: async (ctx: VoterContext) => {\n  voteFor: VoteChoice; // "A" | "B" | "BOTH" | "NEITHER"\n  reasoning: string;\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"example-prefer-goal-reaching-proposals",children:"Example: Prefer Goal-Reaching Proposals"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'const goalVoter = async (ctx: VoterContext) => {\n  const aReachesGoal = ctx.proposalA.toState === "done";\n  const bReachesGoal = ctx.proposalB.toState === "done";\n\n  if (aReachesGoal && !bReachesGoal) {\n    return { voteFor: "A", reasoning: "Proposal A reaches the goal state" };\n  }\n  if (bReachesGoal && !aReachesGoal) {\n    return { voteFor: "B", reasoning: "Proposal B reaches the goal state" };\n  }\n  if (aReachesGoal && bReachesGoal) {\n    return { voteFor: "BOTH", reasoning: "Both proposals reach the goal" };\n  }\n  return { voteFor: "NEITHER", reasoning: "Neither proposal reaches the goal" };\n};\n'})}),"\n",(0,r.jsx)(t.h2,{id:"arbiter-strategy",children:"Arbiter Strategy"}),"\n",(0,r.jsxs)(t.p,{children:["An arbiter ",(0,r.jsx)(t.code,{children:"strategyFn"})," receives an ",(0,r.jsx)(t.code,{children:"ArbiterContext"})," and returns a ",(0,r.jsx)(t.code,{children:"ConsensusResult"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'const myArbiter = async (ctx: ArbiterContext) => {\n  // ctx.proposals: Proposal[] - all proposals in the session\n  // ctx.votes: Vote[] - all votes in the session\n  // ctx.currentState: string\n  // ctx.history: TransitionRecord[]\n\n  // Custom consensus logic\n  const topProposal = ctx.proposals[0];\n  return {\n    consensusReached: true,\n    winningProposalId: topProposal?.proposalId,\n    reasoning: "Custom arbiter selected the first proposal",\n  };\n};\n'})}),"\n",(0,r.jsx)(t.h3,{id:"arbiter-strategyfn-signature",children:"Arbiter strategyFn Signature"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"strategyFn: async (ctx: ArbiterContext) => ConsensusResult\n"})}),"\n",(0,r.jsx)(t.h2,{id:"using-strategies-with-specialists",children:"Using Strategies with Specialists"}),"\n",(0,r.jsx)(t.p,{children:"Register strategies when creating specialists:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'import { registerProposer, registerVoter, registerArbiter } from "dialai";\n\nregisterProposer({\n  specialistId: "goal-proposer",\n  machineName: "my-task",\n  strategyFn: goalDirected,\n});\n\nregisterVoter({\n  specialistId: "goal-voter",\n  machineName: "my-task",\n  strategyFn: goalVoter,\n});\n\nregisterArbiter({\n  specialistId: "custom-arbiter",\n  machineName: "my-task",\n  strategyFn: myArbiter,\n});\n'})}),"\n",(0,r.jsx)(t.h2,{id:"direct-submission",children:"Direct Submission"}),"\n",(0,r.jsx)(t.p,{children:"You can also bypass strategies and submit proposals or votes directly:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'import { submitProposal, submitVote } from "dialai";\n\n// Submit a proposal without a registered strategy\nconst proposal = submitProposal(\n  sessionId,\n  "manual-proposer",\n  "approve",\n  "approved",\n  "Manually approved after review"\n);\n\n// Submit a vote directly\nconst vote = submitVote(\n  sessionId,\n  "manual-voter",\n  proposalA.proposalId,\n  proposalB.proposalId,\n  "A",\n  "Prefer proposal A"\n);\n'})})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},8453(e,t,n){n.d(t,{R:()=>a,x:()=>o});var s=n(6540);const r={},i=s.createContext(r);function a(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);