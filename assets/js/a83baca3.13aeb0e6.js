"use strict";(globalThis.webpackChunkdialai_website=globalThis.webpackChunkdialai_website||[]).push([[7111],{6641(e,n,i){i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"guides/state-machines","title":"State Machines","description":"State machines define the structure of your sessions. Each session type has its own machine definition.","source":"@site/docs/guides/state-machines.md","sourceDirName":"guides","slug":"/guides/state-machines","permalink":"/dialai/docs/guides/state-machines","draft":false,"unlisted":false,"editUrl":"https://github.com/eloquentanalytics/dialai/tree/main/website/docs/guides/state-machines.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Related Work","permalink":"/dialai/docs/concepts/related-work"},"next":{"title":"Registering Specialists","permalink":"/dialai/docs/guides/registering-specialists"}}');var s=i(4848),a=i(8453);const o={sidebar_position:1},r="State Machines",c={},l=[{value:"Why State Machines?",id:"why-state-machines",level:2},{value:"Defining a Machine",id:"defining-a-machine",level:2},{value:"Example",id:"example",level:2},{value:"Machine Definition as JSON",id:"machine-definition-as-json",level:2},{value:"State Configuration",id:"state-configuration",level:2},{value:"<code>prompt</code> (optional)",id:"prompt-optional",level:3},{value:"<code>transitions</code> (optional)",id:"transitions-optional",level:3},{value:"Design Patterns",id:"design-patterns",level:2},{value:"Linear Workflow",id:"linear-workflow",level:3},{value:"Review Loop",id:"review-loop",level:3},{value:"Branching Decisions",id:"branching-decisions",level:3},{value:"Agentic Workflow",id:"agentic-workflow",level:3},{value:"Document Generation",id:"document-generation",level:3},{value:"Decision Prompts",id:"decision-prompts",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"state-machines",children:"State Machines"})}),"\n",(0,s.jsx)(n.p,{children:"State machines define the structure of your sessions. Each session type has its own machine definition."}),"\n",(0,s.jsx)(n.h2,{id:"why-state-machines",children:"Why State Machines?"}),"\n",(0,s.jsx)(n.p,{children:'Every agentic AI system is a state machine: the agent occupies a state, takes an action, and transitions to a new state. Frameworks like LangGraph make this explicit: agents are graphs of states and edges. Even "open-ended" agent loops (observe \u2192 reason \u2192 act \u2192 observe) follow this structure.'}),"\n",(0,s.jsxs)(n.p,{children:["DIAL makes the state machine explicit so that each transition becomes a ",(0,s.jsx)(n.strong,{children:"measurable decision point"}),". This doesn't limit what you can model; it clarifies ",(0,s.jsx)(n.em,{children:"where decisions happen"})," so they can be calibrated. You don't need a DIAL decision point at every micro-step; you place them at the boundaries where delegation risk matters. An agent's internal tool-call loop can remain opaque. DIAL measures the outcomes at the states you care about."]}),"\n",(0,s.jsx)(n.p,{children:"This means open-ended tasks fit naturally:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Document generation"}),": Proposals ",(0,s.jsx)(n.em,{children:"are"})," the candidate documents. Specialists propose drafts, voters compare them, the human picks or edits the winner."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Agentic workflows"}),": The default state is the agent's normal operating mode. It transitions out for decisions that need deliberation (tool selection, plan changes) and back when resolved."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Research and exploration"}),": Model as a loop: the agent explores, then a decision determines whether findings are sufficient or more exploration is needed."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"defining-a-machine",children:"Defining a Machine"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"MachineDefinition"})," defines:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"machineName"}),": identifies the type"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"initialState"}),": where sessions start"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"defaultState"}),": the goal state (session is complete when it reaches this)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"states"}),": a record of state names to their configuration"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import type { MachineDefinition } from "dialai";\n\nconst myMachine: MachineDefinition = {\n  machineName: "my-task",\n  initialState: "idle",\n  defaultState: "done",\n  states: {\n    idle: {\n      prompt: "The system is idle. What should happen next?",\n      transitions: {\n        start: "working",\n        configure: "configuring",\n      },\n    },\n    configuring: {\n      prompt: "Configuration in progress. Apply or cancel?",\n      transitions: {\n        apply: "working",\n        cancel: "idle",\n      },\n    },\n    working: {\n      prompt: "The system is working. Should it continue or finish?",\n      transitions: {\n        finish: "done",\n        reconfigure: "configuring",\n      },\n    },\n    done: {},\n  },\n};\n'})}),"\n",(0,s.jsx)(n.h2,{id:"machine-definition-as-json",children:"Machine Definition as JSON"}),"\n",(0,s.jsx)(n.p,{children:"Machines can also be defined as plain JSON files, useful with the CLI:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "machineName": "simple-task",\n  "initialState": "pending",\n  "defaultState": "done",\n  "states": {\n    "pending": {\n      "prompt": "Should we complete this task?",\n      "transitions": { "complete": "done" }\n    },\n    "done": {}\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Run with the CLI:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"node dist/dialai/cli.js my-machine.json\n"})}),"\n",(0,s.jsx)(n.h2,{id:"state-configuration",children:"State Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["Each state in the ",(0,s.jsx)(n.code,{children:"states"})," record can have:"]}),"\n",(0,s.jsxs)(n.h3,{id:"prompt-optional",children:[(0,s.jsx)(n.code,{children:"prompt"})," (optional)"]}),"\n",(0,s.jsx)(n.p,{children:"A string describing the decision to be made in this state. This prompt guides specialists in choosing which transition to propose."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'states: {\n  reviewing: {\n    prompt: "Review the document. Approve if quality standards are met, otherwise request changes.",\n    transitions: { approve: "approved", request_changes: "needs_revision" },\n  },\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"transitions-optional",children:[(0,s.jsx)(n.code,{children:"transitions"})," (optional)"]}),"\n",(0,s.jsx)(n.p,{children:"A record mapping transition names to target state names. If omitted, the state has no outgoing transitions (terminal state)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'transitions: {\n  approve: "approved",        // transition "approve" \u2192 state "approved"\n  request_changes: "needs_revision",\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"design-patterns",children:"Design Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"linear-workflow",children:"Linear Workflow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'const linear: MachineDefinition = {\n  machineName: "pipeline",\n  initialState: "step1",\n  defaultState: "complete",\n  states: {\n    step1: { transitions: { next: "step2" } },\n    step2: { transitions: { next: "step3" } },\n    step3: { transitions: { next: "complete" } },\n    complete: {},\n  },\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"review-loop",children:"Review Loop"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'const reviewLoop: MachineDefinition = {\n  machineName: "review",\n  initialState: "draft",\n  defaultState: "published",\n  states: {\n    draft: {\n      prompt: "Review the draft. Approve or request revisions?",\n      transitions: {\n        approve: "published",\n        revise: "revising",\n      },\n    },\n    revising: {\n      prompt: "Revisions made. Submit for review?",\n      transitions: { submit: "draft" },\n    },\n    published: {},\n  },\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"branching-decisions",children:"Branching Decisions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'const branching: MachineDefinition = {\n  machineName: "triage",\n  initialState: "incoming",\n  defaultState: "resolved",\n  states: {\n    incoming: {\n      prompt: "Triage this ticket: escalate, handle directly, or close?",\n      transitions: {\n        escalate: "escalated",\n        handle: "in_progress",\n        close: "resolved",\n      },\n    },\n    escalated: {\n      transitions: { resolve: "resolved" },\n    },\n    in_progress: {\n      transitions: { resolve: "resolved", escalate: "escalated" },\n    },\n    resolved: {},\n  },\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"agentic-workflow",children:"Agentic Workflow"}),"\n",(0,s.jsx)(n.p,{children:"An agent's operating loop modeled as a DIAL machine. The default state is the agent running normally: it transitions out when a decision needs deliberation, and back when resolved."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'const agentLoop: MachineDefinition = {\n  machineName: "coding-agent",\n  initialState: "operating",\n  defaultState: "done",\n  states: {\n    operating: {\n      prompt:\n        "The agent is working. Should it continue, use a tool, replan, or finalize?",\n      transitions: {\n        use_tool: "tool_selection",\n        replan: "planning",\n        finalize: "done",\n      },\n    },\n    tool_selection: {\n      prompt: "Which tool should the agent use for this step?",\n      transitions: { selected: "operating" },\n    },\n    planning: {\n      prompt: "The current approach isn\'t working. What should the new plan be?",\n      transitions: { resume: "operating" },\n    },\n    done: {},\n  },\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"document-generation",children:"Document Generation"}),"\n",(0,s.jsxs)(n.p,{children:["For open-ended generation tasks, the specialist proposals ",(0,s.jsx)(n.em,{children:"are"})," the candidate outputs. Voters compare drafts, and the human selects or edits the winner."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'const docGen: MachineDefinition = {\n  machineName: "report-generation",\n  initialState: "drafting",\n  defaultState: "published",\n  states: {\n    drafting: {\n      prompt:\n        "Generate a draft of the report. Each proposal should be a complete draft.",\n      transitions: {\n        accept: "published",\n        revise: "revising",\n      },\n    },\n    revising: {\n      prompt:\n        "Revise the draft based on feedback. Each proposal should be a revised version.",\n      transitions: {\n        accept: "published",\n        revise: "revising",\n      },\n    },\n    published: {},\n  },\n};\n'})}),"\n",(0,s.jsx)(n.h2,{id:"decision-prompts",children:"Decision Prompts"}),"\n",(0,s.jsxs)(n.p,{children:["Each state's ",(0,s.jsx)(n.code,{children:"prompt"})," describes how to decide what to do next. Good prompts are:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Specific"}),": List the available choices and criteria"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Actionable"}),": Tell the specialist what to evaluate"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consistent"}),": Same instructions for all specialists (AI and human)"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'Good: "Review the code changes. Check for: 1) correctness, 2) test coverage,\n      3) documentation. Approve if all criteria met, otherwise request changes."\n\nBad:  "Decide what to do next."\n'})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453(e,n,i){i.d(n,{R:()=>o,x:()=>r});var t=i(6540);const s={},a=t.createContext(s);function o(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);