"use strict";(globalThis.webpackChunkdialai_website=globalThis.webpackChunkdialai_website||[]).push([[2362],{7621(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>r,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"agent-experience","title":"Agent Experience Development","description":"DIAL is designed for LLM-driven agents as first-class participants. Every design decision \u2014 from the API shape to the documentation format to the way changelogs are written \u2014 optimizes for agents that need to understand, integrate with, and act within the framework autonomously.","source":"@site/docs/agent-experience.md","sourceDirName":".","slug":"/agent-experience","permalink":"/dialai/docs/agent-experience","draft":false,"unlisted":false,"editUrl":"https://github.com/eloquentanalytics/dialai/tree/main/website/docs/agent-experience.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to DIAL","permalink":"/dialai/docs/intro"},"next":{"title":"Installation","permalink":"/dialai/docs/getting-started/installation"}}');var s=t(4848),a=t(8453);const r={sidebar_position:2},o="Agent Experience Development",c={},h=[{value:"Agents as Participants",id:"agents-as-participants",level:2},{value:"Spec-Driven Development",id:"spec-driven-development",level:2},{value:"Changelogs as Instructions",id:"changelogs-as-instructions",level:2},{value:"Reference Implementations",id:"reference-implementations",level:2},{value:"Documentation for Agents",id:"documentation-for-agents",level:2},{value:"Tool-Oriented, Not Resource-Oriented",id:"tool-oriented-not-resource-oriented",level:2},{value:"The Constitution",id:"the-constitution",level:2},{value:"Why a Constitution Matters",id:"why-a-constitution-matters",level:3},{value:"Using the Constitution as a System Prefix",id:"using-the-constitution-as-a-system-prefix",level:3},{value:"Spec Change Workflow",id:"spec-change-workflow",level:2},{value:"Versioning",id:"versioning",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"agent-experience-development",children:"Agent Experience Development"})}),"\n",(0,s.jsx)(n.p,{children:"DIAL is designed for LLM-driven agents as first-class participants. Every design decision \u2014 from the API shape to the documentation format to the way changelogs are written \u2014 optimizes for agents that need to understand, integrate with, and act within the framework autonomously."}),"\n",(0,s.jsx)(n.h2,{id:"agents-as-participants",children:"Agents as Participants"}),"\n",(0,s.jsx)(n.p,{children:"The specialist abstraction exists so that LLM agents can register themselves as proposers and voters in a decision cycle. An agent reading a state machine definition can determine what state the session is in, what transitions are available, and what the prompt is asking. It can then submit a proposal or cast a vote using the same API a human would use."}),"\n",(0,s.jsxs)(n.p,{children:["This is the point. DIAL does not treat agents as a backend detail or an orchestration layer. Agents sit alongside humans in the decision cycle and are evaluated by the same arbiter under the same rules. The difference is that human votes override \u2014 not because agents are excluded, but because ",(0,s.jsx)(n.a,{href:"/dialai/docs/concepts/human-primacy",children:"human primacy"})," is a safety constraint on the system."]}),"\n",(0,s.jsx)(n.h2,{id:"spec-driven-development",children:"Spec-Driven Development"}),"\n",(0,s.jsxs)(n.p,{children:["The source of truth for DIAL is its documentation. The code in ",(0,s.jsx)(n.code,{children:"/src"})," is generated from the documentation files \u2014 not the other way around."]}),"\n",(0,s.jsxs)(n.p,{children:["This means an agent reading the docs has the authoritative specification. If the docs say ",(0,s.jsx)(n.code,{children:"executeTransition"})," accepts an optional ",(0,s.jsx)(n.code,{children:"reasoning"})," parameter and records a ",(0,s.jsx)(n.code,{children:"TransitionRecord"})," in ",(0,s.jsx)(n.code,{children:"session.history"}),", that is what the implementation does. An agent does not need to read the TypeScript source to understand the contract. The docs are the contract."]}),"\n",(0,s.jsx)(n.p,{children:"This also means the docs are written with the precision an agent needs: exact function signatures, explicit parameter types, concrete return values. Prose explains intent. Code blocks define behavior."}),"\n",(0,s.jsx)(n.h2,{id:"changelogs-as-instructions",children:"Changelogs as Instructions"}),"\n",(0,s.jsx)(n.p,{children:"Commit messages and changelogs in the DIAL repository are written as instructions to an LLM that is maintaining a codebase which depends on DIAL."}),"\n",(0,s.jsxs)(n.p,{children:["A conventional changelog entry tells a human what changed. A DIAL changelog entry tells an agent ",(0,s.jsx)(n.strong,{children:"what to do about it"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"What the change is"}),"\n",(0,s.jsx)(n.li,{children:"What call sites are affected"}),"\n",(0,s.jsx)(n.li,{children:"What the migration path is"}),"\n",(0,s.jsx)(n.li,{children:"What the new behavior looks like in code"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This is a deliberate choice. The primary consumer of DIAL's change history is an agent that needs to update its integration. The writing style reflects that."}),"\n",(0,s.jsx)(n.h2,{id:"reference-implementations",children:"Reference Implementations"}),"\n",(0,s.jsx)(n.p,{children:"DIAL ships reference implementations in TypeScript as CLI tools. The CLI accepts a machine definition as JSON and runs it to completion:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"node dist/dialai/cli.js examples/simple-machine.json\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Session type:  is-two-greater\nInitial state: unsure\nGoal state:    sure\nFinal state:   sure\nSession ID:    a1b2c3d4-...\n"})}),"\n",(0,s.jsx)(n.p,{children:"The CLI is minimal by design. It demonstrates the exact sequence of API calls an agent would make \u2014 create a session, register specialists, solicit proposals, evaluate consensus, execute transitions \u2014 in a form that is easy for an agent to read, replicate, and extend."}),"\n",(0,s.jsx)(n.p,{children:"The help documentation and error messages are written for LLM comprehension. When the CLI fails, it says what went wrong and what the valid inputs are, in plain text that an agent can parse and act on."}),"\n",(0,s.jsx)(n.h2,{id:"documentation-for-agents",children:"Documentation for Agents"}),"\n",(0,s.jsx)(n.p,{children:"DIAL documentation is served in two forms:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Traditional web"})," \u2014 the Docusaurus site you are reading now, with structured navigation, code examples, and concept explanations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"llms.txt"})," \u2014 a machine-readable format generated by the ",(0,s.jsx)(n.a,{href:"https://github.com/signalwire/docusaurus-plugin-llms",children:"docusaurus-plugin-llms"})," plugin, which concatenates all documentation into a single text file optimized for LLM context windows"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"llms.txt"})," format allows an agent to ingest the entire DIAL specification in one read operation rather than navigating a site. Both formats contain the same information. The web form is organized for browsing. The ",(0,s.jsx)(n.code,{children:"llms.txt"})," form is organized for ingestion."]}),"\n",(0,s.jsx)(n.h2,{id:"tool-oriented-not-resource-oriented",children:"Tool-Oriented, Not Resource-Oriented"}),"\n",(0,s.jsxs)(n.p,{children:["DIAL's API is ",(0,s.jsx)(n.strong,{children:"tool-oriented"})," rather than resource-oriented. The distinction matters for agents."]}),"\n",(0,s.jsx)(n.p,{children:'A resource-oriented API exposes data: "here is a session, here are its proposals, here are its votes." An agent working with a resource-oriented API must figure out the correct sequence of reads and writes to accomplish a goal.'}),"\n",(0,s.jsxs)(n.p,{children:["A tool-oriented API exposes actions: ",(0,s.jsx)(n.code,{children:"submitProposal"}),", ",(0,s.jsx)(n.code,{children:"submitVote"}),", ",(0,s.jsx)(n.code,{children:"evaluateConsensus"}),", ",(0,s.jsx)(n.code,{children:"executeTransition"}),". Each function is a discrete action with a clear purpose. An agent with tool-use capabilities can map these directly to its tool-calling interface."]}),"\n",(0,s.jsx)(n.p,{children:"The 10 functions in the DIAL API are designed to be the 10 tools an agent needs:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Function"}),(0,s.jsx)(n.th,{children:"Action"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"createSession"})}),(0,s.jsx)(n.td,{children:"Start a new decision process"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"getSession"})}),(0,s.jsx)(n.td,{children:"Check the current state"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"getSessions"})}),(0,s.jsx)(n.td,{children:"List all active processes"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"registerSpecialist"})}),(0,s.jsx)(n.td,{children:"Join a decision process as a participant"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"submitProposal"})}),(0,s.jsx)(n.td,{children:"Propose a transition"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"solicitProposal"})}),(0,s.jsx)(n.td,{children:"Ask a specialist's strategy to propose"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"submitVote"})}),(0,s.jsx)(n.td,{children:"Cast a vote between two proposals"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"solicitVote"})}),(0,s.jsx)(n.td,{children:"Ask a specialist's strategy to vote"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"evaluateConsensus"})}),(0,s.jsx)(n.td,{children:"Check if the group has reached agreement"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"executeTransition"})}),(0,s.jsx)(n.td,{children:"Apply the winning proposal"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["An agent calling ",(0,s.jsx)(n.code,{children:'submitProposal(sessionId, myId, "approve", "approved", "Document meets quality standards")'})," is doing exactly one thing: proposing a state transition. There is no ambiguity about what the call does, what it returns, or what happens next."]}),"\n",(0,s.jsx)(n.p,{children:'This is agent experience development. The framework is built so that the agent\'s path from "I have a task" to "I took an action" is as short and unambiguous as possible.'}),"\n",(0,s.jsx)(n.h2,{id:"the-constitution",children:"The Constitution"}),"\n",(0,s.jsxs)(n.p,{children:["DIAL publishes a ",(0,s.jsx)(n.a,{href:"/constitution",children:"Constitution"})," \u2014 a detailed description of how AI specialists should reason and behave within the framework. It is not a policy document for humans. It is written with the specialist as its primary audience, optimized for precision over accessibility, because a specialist needs to be able to cite it during reasoning."]}),"\n",(0,s.jsx)(n.h3,{id:"why-a-constitution-matters",children:"Why a Constitution Matters"}),"\n",(0,s.jsx)(n.p,{children:'An LLM acting as a DIAL specialist faces a specific problem: it needs to know what "good behavior" means before it encounters any particular decision. The constitution solves this by defining a priority hierarchy (alignment with humans first, faithfulness to the prompt second, honesty third, usefulness fourth), hard constraints (no fabrication, no coordination between specialists, no manipulating the arbiter), and concrete guidance for making proposals and casting votes.'}),"\n",(0,s.jsx)(n.p,{children:"Without the constitution, every specialist would invent its own interpretation of what DIAL expects. The system's measurements would reflect inconsistent reasoning rather than genuine alignment differences. The constitution makes the rules explicit so the signal is clean."}),"\n",(0,s.jsx)(n.h3,{id:"using-the-constitution-as-a-system-prefix",children:"Using the Constitution as a System Prefix"}),"\n",(0,s.jsx)(n.p,{children:"We encourage any agent acting as a DIAL specialist to prefix its system prompt with the constitution text. The constitution is designed for exactly this use: it fits within a context window, it uses precise language an LLM can follow, and every principle is structured so the specialist can trace a decision back to a specific section."}),"\n",(0,s.jsx)(n.p,{children:"A specialist that has internalized the constitution will:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Defer to demonstrated human preferences over its own reasoning"}),"\n",(0,s.jsx)(n.li,{children:"Express calibrated confidence rather than fabricating conviction"}),"\n",(0,s.jsx)(n.li,{children:"Submit NULL proposals or vote NEITHER when genuinely uncertain"}),"\n",(0,s.jsx)(n.li,{children:"Cite the decision prompt and session history as evidence, not its own independent analysis"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This is also how we use the constitution in fine-tuning. Training data for DIAL specialists is evaluated against the constitution's priority hierarchy. A training example where the specialist overrides a human preference \u2014 no matter how \"correct\" the specialist's reasoning appears \u2014 is a negative example. The constitution defines what correct means, and correct means aligned with the human."}),"\n",(0,s.jsxs)(n.p,{children:["The full text is available at ",(0,s.jsx)(n.a,{href:"/constitution",children:"/constitution"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"spec-change-workflow",children:"Spec Change Workflow"}),"\n",(0,s.jsx)(n.p,{children:"When a specification is updated, the change propagates through the codebase in a fixed order. This order is not a suggestion \u2014 it is the procedure an agent maintaining DIAL follows on every spec change."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Update the tests"})," \u2014 The spec changed, so the tests must change first. Write or modify tests that assert the new behavior described in the updated docs. These tests will fail. That is correct."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Update the implementation"})," \u2014 Modify the code in ",(0,s.jsx)(n.code,{children:"/src"})," until the new tests pass and no existing tests regress."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Run the tests against the example machines"})," \u2014 Execute every machine definition in ",(0,s.jsx)(n.code,{children:"/examples"})," through the CLI and programmatic API. The examples are integration tests. If a spec change breaks an example, the example is wrong \u2014 not the spec."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fix the example machines"})," \u2014 Update any example that fails to conform to the new spec. Record what changed in each example and why."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Synthesize and write the changelog"})," \u2014 Combine the spec change, the implementation change, and the example fixes into a single changelog entry. Write it as an instruction to an agent that depends on DIAL: what changed, what breaks, what to do about it."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Each change like this is a ",(0,s.jsx)(n.strong,{children:"branch"}),". The branch contains a series of commits following the steps above. When the branch is merged, the merge commit carries the changelog message and a version bump."]}),"\n",(0,s.jsx)(n.h3,{id:"versioning",children:"Versioning"}),"\n",(0,s.jsxs)(n.p,{children:["The current version is tracked in ",(0,s.jsx)(n.code,{children:"VERSION.md"})," at the repository root. The format is a single line containing the semantic version number. The merge commit that closes a spec change branch increments the version:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Patch"})," \u2014 bug fixes, example corrections, doc clarifications that do not change behavior"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Minor"})," \u2014 new functions, new parameters, new fields on existing types"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Major"})," \u2014 removed functions, changed return types, changed parameter semantics"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The version in ",(0,s.jsx)(n.code,{children:"VERSION.md"})," is the version. There is no ",(0,s.jsx)(n.code,{children:"package.json"})," version to keep in sync, no release script to run. An agent reading ",(0,s.jsx)(n.code,{children:"VERSION.md"})," knows what version of the spec the codebase implements."]})]})}function l(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);