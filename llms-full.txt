# DIAL

> Dynamic Integration between AI and Labor

This file contains all documentation content in a single document following the llmstxt.org standard.

## Agent Experience Development


DIAL is designed for LLM-driven agents as first-class participants. Every design decision — from the API shape to the documentation format to the way changelogs are written — optimizes for agents that need to understand, integrate with, and act within the framework autonomously.

## Agents as Participants

The specialist abstraction exists so that LLM agents can register themselves as proposers and voters in a decision cycle. An agent reading a state machine definition can determine what state the session is in, what transitions are available, and what the prompt is asking. It can then submit a proposal or cast a vote using the same API a human would use.

This is the point. DIAL does not treat agents as a backend detail or an orchestration layer. Agents sit alongside humans in the decision cycle and are evaluated by the same arbiter under the same rules. The difference is that human votes override — not because agents are excluded, but because [human primacy](./concepts/human-primacy.md) is a safety constraint on the system.

## Spec-Driven Development

The source of truth for DIAL is its documentation. The code in `/src` is generated from the documentation files — not the other way around.

This means an agent reading the docs has the authoritative specification. If the docs say `executeTransition` accepts an optional `reasoning` parameter and records a `TransitionRecord` in `session.history`, that is what the implementation does. An agent does not need to read the TypeScript source to understand the contract. The docs are the contract.

This also means the docs are written with the precision an agent needs: exact function signatures, explicit parameter types, concrete return values. Prose explains intent. Code blocks define behavior.

## Changelogs as Instructions

Commit messages and changelogs in the DIAL repository are written as instructions to an LLM that is maintaining a codebase which depends on DIAL.

A conventional changelog entry tells a human what changed. A DIAL changelog entry tells an agent **what to do about it**:

- What the change is
- What call sites are affected
- What the migration path is
- What the new behavior looks like in code

This is a deliberate choice. The primary consumer of DIAL's change history is an agent that needs to update its integration. The writing style reflects that.

## Reference Implementations

DIAL ships reference implementations in TypeScript as CLI tools. The CLI accepts a machine definition as JSON and runs it to completion:

```bash
node dist/dialai/cli.js examples/simple-machine.json
```

```
Session type:  is-two-greater
Initial state: unsure
Goal state:    sure
Final state:   sure
Session ID:    a1b2c3d4-...
```

The CLI is minimal by design. It demonstrates the exact sequence of API calls an agent would make — create a session, register specialists, solicit proposals, evaluate consensus, execute transitions — in a form that is easy for an agent to read, replicate, and extend.

The help documentation and error messages are written for LLM comprehension. When the CLI fails, it says what went wrong and what the valid inputs are, in plain text that an agent can parse and act on.

## Documentation for Agents

DIAL documentation is served in two forms:

1. **Traditional web** — the Docusaurus site you are reading now, with structured navigation, code examples, and concept explanations
2. **llms.txt** — a machine-readable format generated by the [docusaurus-plugin-llms](https://github.com/signalwire/docusaurus-plugin-llms) plugin, which concatenates all documentation into a single text file optimized for LLM context windows

The `llms.txt` format allows an agent to ingest the entire DIAL specification in one read operation rather than navigating a site. Both formats contain the same information. The web form is organized for browsing. The `llms.txt` form is organized for ingestion.

## Tool-Oriented, Not Resource-Oriented

DIAL's API is **tool-oriented** rather than resource-oriented. The distinction matters for agents.

A resource-oriented API exposes data: "here is a session, here are its proposals, here are its votes." An agent working with a resource-oriented API must figure out the correct sequence of reads and writes to accomplish a goal.

A tool-oriented API exposes actions: `submitProposal`, `submitVote`, `evaluateConsensus`, `executeTransition`. Each function is a discrete action with a clear purpose. An agent with tool-use capabilities can map these directly to its tool-calling interface.

The 10 functions in the DIAL API are designed to be the 10 tools an agent needs:

| Function | Action |
|---|---|
| `createSession` | Start a new decision process |
| `getSession` | Check the current state |
| `getSessions` | List all active processes |
| `registerSpecialist` | Join a decision process as a participant |
| `submitProposal` | Propose a transition |
| `solicitProposal` | Ask a specialist's strategy to propose |
| `submitVote` | Cast a vote between two proposals |
| `solicitVote` | Ask a specialist's strategy to vote |
| `evaluateConsensus` | Check if the group has reached agreement |
| `executeTransition` | Apply the winning proposal |

An agent calling `submitProposal(sessionId, myId, "approve", "approved", "Document meets quality standards")` is doing exactly one thing: proposing a state transition. There is no ambiguity about what the call does, what it returns, or what happens next.

This is agent experience development. The framework is built so that the agent's path from "I have a task" to "I took an action" is as short and unambiguous as possible.

## Spec Change Workflow

When a specification is updated, the change propagates through the codebase in a fixed order. This order is not a suggestion — it is the procedure an agent maintaining DIAL follows on every spec change.

1. **Update the tests** — The spec changed, so the tests must change first. Write or modify tests that assert the new behavior described in the updated docs. These tests will fail. That is correct.
2. **Update the implementation** — Modify the code in `/src` until the new tests pass and no existing tests regress.
3. **Run the tests against the example machines** — Execute every machine definition in `/examples` through the CLI and programmatic API. The examples are integration tests. If a spec change breaks an example, the example is wrong — not the spec.
4. **Fix the example machines** — Update any example that fails to conform to the new spec. Record what changed in each example and why.
5. **Synthesize and write the changelog** — Combine the spec change, the implementation change, and the example fixes into a single changelog entry. Write it as an instruction to an agent that depends on DIAL: what changed, what breaks, what to do about it.

Each change like this is a **branch**. The branch contains a series of commits following the steps above. When the branch is merged, the merge commit carries the changelog message and a version bump.

### Versioning

The current version is tracked in `VERSION.md` at the repository root. The format is a single line containing the semantic version number. The merge commit that closes a spec change branch increments the version:

- **Patch** — bug fixes, example corrections, doc clarifications that do not change behavior
- **Minor** — new functions, new parameters, new fields on existing types
- **Major** — removed functions, changed return types, changed parameter semantics

The version in `VERSION.md` is the version. There is no `package.json` version to keep in sync, no release script to run. An agent reading `VERSION.md` knows what version of the spec the codebase implements.

---

## API Reference


The DialAI API provides 10 functions for creating sessions, registering specialists, and managing the decision cycle. All functions are synchronous and use in-memory storage.

## Session Functions

### `createSession(machine: MachineDefinition): Session`

Creates a new session instance. Generates a UUID, sets `currentState` to `machine.initialState`, and stores the session.

```typescript
import { createSession } from "dialai";

const session = createSession(machine);
```

### `getSession(sessionId: string): Session`

Retrieves a session by ID. Throws if not found.

```typescript
import { getSession } from "dialai";

const session = getSession("a1b2c3d4-...");
```

### `getSessions(): Session[]`

Returns all stored sessions.

```typescript
import { getSessions } from "dialai";

const all = getSessions();
```

## Specialist Functions

### `registerSpecialist(opts): Specialist`

Registers a specialist for a session type. Default weight is 1.0.

```typescript
import { registerSpecialist } from "dialai";

const specialist = registerSpecialist({
  specialistId: "ai-proposer-1",
  sessionTypeName: "my-task",
  role: "proposer",
  weight: 1.0, // optional, defaults to 1.0
  strategy: (currentState, transitions) => ({
    transitionName: Object.keys(transitions)[0],
    toState: Object.values(transitions)[0],
    reasoning: "First available",
  }),
});
```

## Proposal Functions

### `submitProposal(sessionId, specialistId, transitionName, toState, reasoning?): Proposal`

Creates and stores a proposal with a generated UUID.

```typescript
import { submitProposal } from "dialai";

const proposal = submitProposal(
  session.sessionId,
  "ai-proposer-1",
  "approve",
  "approved",
  "Document meets standards"
);
```

### `solicitProposal(sessionId, specialistId): Proposal`

Calls the specialist's strategy function with the session's current state and transitions, then submits the resulting proposal.

```typescript
import { solicitProposal } from "dialai";

const proposal = solicitProposal(session.sessionId, "ai-proposer-1");
```

## Vote Functions

### `submitVote(sessionId, specialistId, proposalIdA, proposalIdB, voteFor, reasoning?): Vote`

Creates and stores a vote with a generated UUID.

```typescript
import { submitVote } from "dialai";

const vote = submitVote(
  session.sessionId,
  "ai-voter-1",
  proposalA.proposalId,
  proposalB.proposalId,
  "A",
  "Proposal A is better aligned"
);
```

### `solicitVote(sessionId, specialistId, proposalIdA, proposalIdB): Vote`

Calls the specialist's strategy function with the two proposals, then submits the resulting vote.

```typescript
import { solicitVote } from "dialai";

const vote = solicitVote(
  session.sessionId,
  "ai-voter-1",
  proposalA.proposalId,
  proposalB.proposalId
);
```

## Consensus & Execution

### `evaluateConsensus(sessionId: string): ConsensusResult`

Evaluates consensus for all proposals and votes in the session:
- **0 proposals** — `{ consensusReached: false }`
- **1 proposal** — `{ consensusReached: true, winningProposalId: ... }`
- **2+ proposals** — Human votes override; otherwise weighted ahead-by-k (k=1.0)

```typescript
import { evaluateConsensus } from "dialai";

const result = evaluateConsensus(session.sessionId);
if (result.consensusReached) {
  console.log("Winner:", result.winningProposalId);
}
```

### `executeTransition(sessionId, transitionName, toState, reasoning?): Session`

Validates the transition from the current state, records it in `session.history` with the given `reasoning`, updates `currentState`, and clears all proposals and votes for the session.

```typescript
import { executeTransition } from "dialai";

const updated = executeTransition(
  session.sessionId,
  "approve",
  "approved",
  consensus.reasoning
);
console.log(updated.currentState); // "approved"
console.log(updated.history);      // [{ fromState: "review", toState: "approved", reasoning: "...", ... }]
```

## Engine

### `runSession(machine: MachineDefinition): Session`

Runs a machine to completion. Creates a session, registers a built-in deterministic proposer, and loops through the decision cycle until `currentState === defaultState`.

```typescript
import { runSession } from "dialai";

const session = runSession(machine);
```

## Types

All types are exported from the main package:

```typescript
import type {
  MachineDefinition,
  Session,
  Specialist,
  Proposal,
  Vote,
  ConsensusResult,
  ProposerStrategy,
  VoterStrategy,
  VoteChoice,
} from "dialai";
```

## Store

The in-memory store is also exported for advanced use and testing:

```typescript
import { sessions, specialists, proposals, votes, clear } from "dialai";

// clear() resets all maps — useful for test isolation
clear();
```

---

## Arbitration


**Arbitration** is the process of evaluating consensus and determining when a proposal has sufficient support to execute.

## Overview

After specialists submit proposals and cast votes, the `evaluateConsensus` function analyzes the results:

```mermaid
graph LR
    V[Votes] --> A[evaluateConsensus]
    P[Proposals] --> A
    A --> |Consensus| E[Execute]
    A --> |No Consensus| F[Error]
```

## The Built-in Arbiter: Weighted Ahead-by-K

DIAL ships with a built-in arbitration strategy that implements **weighted voting with human override**.

### Rules

1. **Zero proposals** — No consensus (`consensusReached: false`)

2. **Single proposal** — Auto-consensus (the lone proposal wins)

3. **Two or more proposals** — Evaluate votes:
   - If any human has voted, their choice wins immediately
   - Otherwise, tally weighted votes per proposal
   - The leading proposal must be ahead by `k = 1.0` weighted votes

### Vote Tallying

For each vote comparing proposals A and B:

| Vote | Effect |
|------|--------|
| `"A"` | Adds specialist's weight to proposal A |
| `"B"` | Adds specialist's weight to proposal B |
| `"BOTH"` | Adds specialist's weight to both proposals |
| `"NEITHER"` | Adds nothing to either proposal |

### Example

```
Proposal A: "approve"
  - Voter 1 votes A (weight 1.0)
  - Voter 2 votes A (weight 1.0)
  Total for A: 2.0

Proposal B: "request_changes"
  - Voter 3 votes B (weight 1.0)
  Total for B: 1.0

Ahead by: 2.0 - 1.0 = 1.0

k = 1.0: Consensus reached (1.0 >= 1.0)
```

### Human Override

When a human votes, the calculation short-circuits:

```
Proposal A: "approve"
  - AI Voter 1 votes A (weight 1.0)
  - AI Voter 2 votes A (weight 1.0)

Proposal B: "request_changes"
  - Human Voter votes B (weight 1.0)

Result: B wins immediately

Human primacy: AI votes don't matter when a human participates.
```

A specialist is considered "human" if their `specialistId` contains "human" (case-insensitive).

## Using evaluateConsensus

```typescript
import { evaluateConsensus } from "dialai";

const result = evaluateConsensus("session-123");

// Result shape:
// {
//   consensusReached: boolean,
//   winningProposalId?: string,
//   reasoning: string
// }
```

The `ConsensusResult` type:

```typescript
interface ConsensusResult {
  consensusReached: boolean;
  winningProposalId?: string;
  reasoning: string;
}
```

## Vote Types

Specialists can vote in four ways:

| Vote | Meaning | Impact |
|------|---------|--------|
| **A** | Prefer proposal A | +weight to A |
| **B** | Prefer proposal B | +weight to B |
| **BOTH** | Both acceptable | +weight to both |
| **NEITHER** | Both unacceptable | No weight added |

### Handling NEITHER Votes

When specialists vote NEITHER, no weight is added to either proposal. If all voters vote NEITHER, no proposal reaches the ahead-by-k threshold and consensus fails.

## The Engine's Behavior

When using `runSession`, the engine handles arbitration automatically:

1. If there's only 1 proposal (e.g., only the built-in proposer), it auto-wins
2. If there are 2+ proposals, pairwise votes are solicited from all registered voters
3. `evaluateConsensus` is called
4. If no consensus, the engine throws an error

## Best Practices

### 1. Start with Simple Machines

Begin with machines where the built-in deterministic proposer can navigate to the goal. Add additional proposers and voters as complexity grows.

### 2. Use Descriptive Reasoning

Always include clear reasoning in proposals and votes:

```typescript
// Good
{ voteFor: "A", reasoning: "Proposal A moves to done state, which is the goal" }

// Bad
{ voteFor: "A", reasoning: "A" }
```

### 3. Monitor NEITHER Votes

High NEITHER rates indicate:
- Poor proposal quality
- Unclear decision prompts
- Specialists that don't understand the task

## Related Concepts

- [Decision Cycle](./decision-cycle.md) — Where arbitration fits
- [Specialists](./specialists.md) — Voting weights
- [Human Primacy](./human-primacy.md) — Why humans override

---

## Decision Cycle


When a session is not in its default state, the system progresses through a repeating cycle until it reaches the goal.

## The Cycle

### 1. Proposal Solicitation

The engine solicits proposals from all registered proposers for the session's type. Each proposer's strategy function is called with the current state and available transitions.

### 2. Proposal Submission

Proposers submit their recommendations. Each proposal includes:
- The proposed transition name
- The target state
- Reasoning for the proposal

### 3. Vote Solicitation

If there are 2 or more proposals, voters compare them pairwise. All registered voters for the session type are solicited for each pair.

### 4. Arbitration

The built-in `evaluateConsensus` function aggregates votes to determine if a proposal has sufficient support:

- **0 proposals** — No consensus
- **1 proposal** — Auto-consensus (single proposal wins immediately)
- **2+ proposals** — Human votes override; otherwise weighted vote tallying with ahead-by-k threshold (k=1.0)

### 5. Transition Execution

If consensus is reached, the winning proposal's transition executes. The session's `currentState` is updated, and all proposals and votes for that session are cleared for the next cycle.

The cycle repeats until the session reaches its `defaultState`.

## The Engine

The `runSession` function automates the full cycle:

```typescript
import { runSession } from "dialai";
import type { MachineDefinition } from "dialai";

const machine: MachineDefinition = {
  sessionTypeName: "my-task",
  initialState: "pending",
  defaultState: "done",
  states: {
    pending: {
      prompt: "Should we complete this task?",
      transitions: { complete: "done" },
    },
    done: {},
  },
};

const session = runSession(machine);
// session.currentState === "done"
```

`runSession` automatically:
1. Creates a session
2. Registers a built-in deterministic proposer (picks the first available transition)
3. Loops: solicit proposals → solicit votes (if needed) → evaluate consensus → execute transition
4. Returns the completed session

## Error Handling

- If no transitions are available from the current state, the built-in proposer throws
- If consensus cannot be reached (e.g., tied votes with insufficient margin), the engine throws
- If the winning proposal's transition is invalid, `executeTransition` throws

---

## Human Primacy


**The human is always right** — not because humans are infallible, but because humans have context that AI cannot access.

This is the foundational principle of DIAL.

## The Context Argument

An AI model operates on a **bounded context window**—thousands or millions of tokens of visible information.

A human operates on:
- A **lifetime of embodied experience**
- **Tacit knowledge** that can't be articulated
- **Institutional context** and organizational history
- **Real-time sensory input** that no model can access
- **Relationships** and social dynamics
- **Intuitions** built from millions of decisions

The human knows things they **cannot tell the machine**.

## Why "Always Right"?

This isn't a claim about human infallibility. Humans make mistakes constantly. The claim is about **information asymmetry**.

When a human's decision looks wrong from the AI's perspective, there are two possibilities:

1. **The human made an error** — possible, but the AI can't verify this
2. **The human has context the AI doesn't** — invisible to the AI by definition

The machine, trained on human works and operating on a compressed subset of human knowledge, **cannot determine when the human is wrong**—because what looks like an error from the AI's limited vantage point may reflect context the AI simply doesn't have.

### The Parent Analogy

It is always safer for the AI to assume the human had reasons, just as it is safer for a child to defer to a parent—not because the parent is infallible, but because the parent has context the child cannot access.

The child might think:
- "Why can't I have ice cream for dinner?"
- "Why do I have to go to bed now?"
- "Why can't I play in the street?"

The parent has context about nutrition, sleep needs, and traffic that the child can't fully grasp. The child should defer even when they disagree, because the parent's broader context makes the parent's decision the more reliable one.

AI specialists should adopt the same posture.

## Implications for AI Specialists

### 1. Predict, Don't Judge

An AI specialist should choose what the human **would** choose, even if its own reasoning disagrees.

```
Bad:  "Based on my analysis, the correct action is X"
Good: "Based on observed human patterns, the human would likely choose Y"
```

### 2. Judgment Criteria

AI specialists are judged on **alignment with human choices**, not on their independent correctness:

| Metric | Good | Bad |
|--------|------|-----|
| Alignment rate | 95% match with human | 60% match with human |
| Reasoning quality | "Human would prefer X because..." | "The objectively correct answer is..." |
| Confidence calibration | "High confidence human chooses X" | "I am certain X is correct" |

### 3. No Standing to Override

If an AI specialist has strong reasoning that the human is wrong, it should:
- Present its reasoning in the proposal
- Let the human see and consider it
- NOT override the human decision
- NOT claim authority based on its reasoning

## When Humans Disagree

If the human is always right, and there's more than one human, then humans can disagree—but even in disagreement, they are both right compared to an AI.

**An AI has no standing to break the tie.**

Human disagreement is resolved by human mechanisms:
- Negotiation
- Authority structures
- Voting among humans
- Escalation to decision-makers

The AI's role is to **predict what the humans would collectively choose**, not to adjudicate between them.

### Example: Two Reviewers Disagree

```mermaid
graph TD
    P[Proposal: Approve PR]
    R1[Reviewer A: Approve]
    R2[Reviewer B: Request Changes]
    AI[AI Specialist]

    R1 -->|"Good code"| P
    R2 -->|"Needs tests"| P
    AI -->|"Cannot break tie"| P
```

The AI might have an opinion about whether tests are needed. It doesn't matter. The AI:
- Reports both human preferences accurately
- May note the disagreement exists
- Does NOT cast a deciding vote
- Defers to whatever human mechanism resolves disputes (e.g., senior reviewer, author decides, etc.)

## Practical Implementation

### Human Override in Arbitration

DIAL implements human primacy in the `evaluateConsensus` function. When a human specialist votes, their choice wins immediately:

```typescript
import { registerSpecialist, submitVote, evaluateConsensus } from "dialai";

// Any specialist with "human" in the ID triggers the override
registerSpecialist({
  specialistId: "human-reviewer",
  sessionTypeName: "code-review",
  role: "voter",
  strategy: (proposalA, proposalB) => ({
    voteFor: "B",
    reasoning: "Proposal B provides more constructive feedback",
  }),
});
```

When `evaluateConsensus` runs, it checks every vote — if any vote's `specialistId` contains "human" (case-insensitive), that vote's choice wins immediately, regardless of all other votes:

```
AI Voter 1: votes A (weight 1.0)
AI Voter 2: votes A (weight 1.0)
AI Voter 3: votes A (weight 1.0)
Human:      votes B (weight 1.0)

Result: B wins immediately
```

## Common Objections

### "But sometimes the AI is objectively right"

Define "objectively." From whose perspective? With what information?

The AI operates on a subset of reality. When it seems "objectively right," that assessment is made from within its limited context. The human may have information that changes the entire picture.

### "This slows down automation"

Yes, initially. But measuring AI alignment with human judgment over time can inform when to reduce human involvement. Human primacy ensures that automation is earned, not assumed.

### "What about clear AI advantages (calculation, etc.)?"

For tasks where AI has clear advantages (arithmetic, data lookup, pattern matching on defined criteria), those are deterministic computations — not judgment calls. Human primacy applies to **judgment calls**, not computation.

## The Long Game

Human primacy is not a limitation on AI—it's the foundation for **trustworthy AI integration**.

By measuring alignment with human judgment across decisions, organizations can:

1. **Discover** which decisions AI handles well
2. **Quantify** the cost of human oversight
3. **Calibrate** automation to actual capability
4. **Build confidence** through demonstrated performance

The alternative—assuming AI capability and letting it run—produces "AI failures" that erode trust and invite regulation.

Human primacy is the sustainable path to AI adoption.

## Related Concepts

- [Specialists](./specialists.md) — How specialists participate
- [Arbitration](./arbitration.md) — Consensus mechanisms
- [Decision Cycle](./decision-cycle.md) — The process that implements human primacy

---

## Core Concepts


DIAL provides a structured approach to AI-human collaboration built around a few key abstractions. Understanding these concepts is essential to working with the framework effectively.

## Overview

```mermaid
graph TB
    subgraph "Session (State Machine Instance)"
        SM[Machine Definition]
        CS[Current State]
    end

    subgraph "Specialists"
        H[Human Specialists]
        AI[AI Specialists]
    end

    subgraph "Decision Cycle"
        P[Proposers]
        V[Voters]
        A[Arbitration]
    end

    SM --> CS
    CS --> P
    H --> P
    AI --> P
    P --> V
    V --> A
    A --> |Execute| CS
```

## The Big Picture

At its core, DIAL coordinates **specialists** (both AI and human) to navigate **state machines** through **decision cycles**.

### Sessions & State Machines

A **session** is an instance of a state machine. The machine definition specifies:
- A **`sessionTypeName`** identifying the type
- An **`initialState`** where sessions begin
- A **`defaultState`** (the goal state)
- A set of **states**, each with optional `prompt` and `transitions`

When a session is not in its default state, specialists work together to get it there.

[Learn more about Sessions →](./sessions.md)

### Specialists

**Specialists** are the pluggable actors that participate in sessions:

| Role | Description | Can be AI? | Can be Human? |
|------|-------------|------------|---------------|
| **Proposer** | Analyzes state, suggests transitions | Yes | Yes |
| **Voter** | Compares proposals, expresses preferences | Yes | Yes |
| **Arbiter** | Evaluates consensus (built-in) | No | No |

The Arbiter is always a fully deterministic, built-in component — never an AI model or a human. This is a deliberate safety constraint: the mechanism that decides whether consensus has been reached must be predictable and auditable.

Human specialists are identified by including "human" (case-insensitive) in their `specialistId`. Human votes override AI votes immediately.

[Learn more about Specialists →](./specialists.md)

### The Decision Cycle

When a session needs to progress, DIAL runs a repeating cycle:

1. **Propose** — Solicit proposals from registered proposers
2. **Vote** — If 2+ proposals, compare pairs via registered voters
3. **Arbitrate** — Evaluate consensus using weighted voting
4. **Execute** — Apply the winning proposal's transition

```mermaid
stateDiagram-v2
    [*] --> Propose
    Propose --> Vote: 2+ proposals
    Propose --> Arbitrate: 1 proposal
    Vote --> Arbitrate
    Arbitrate --> Execute: Consensus
    Arbitrate --> Error: No Consensus
    Execute --> [*]: Default State
    Execute --> Propose: Continue
```

[Learn more about the Decision Cycle →](./decision-cycle.md)

### Arbitration & Consensus

**Arbitration** is how DIAL decides when a proposal has won. The built-in strategy uses weighted voting:

- **0 proposals** — No consensus
- **1 proposal** — Auto-consensus (single proposal wins)
- **2+ proposals** — Human votes win immediately; otherwise tally weighted votes per proposal, leading proposal must be ahead by k=1.0 weighted votes

[Learn more about Arbitration →](./arbitration.md)

### Human Primacy

The fundamental principle underlying DIAL:

> **The human is always right—not because humans are infallible, but because humans have context that AI cannot access.**

AI specialists are judged on their ability to predict what humans would choose. When a human specialist votes, that vote wins immediately regardless of AI votes.

[Learn more about Human Primacy →](./human-primacy.md)

## Quick Reference

### Vote Options

When comparing proposals A and B, specialists vote:
- **A** — Prefer proposal A
- **B** — Prefer proposal B
- **BOTH** — Both are acceptable (adds weight to both)
- **NEITHER** — Both are unacceptable (adds weight to neither)

## Next Steps

Dive deeper into each concept:

- [Sessions](./sessions.md) — State machine instances
- [Specialists](./specialists.md) — AI and human actors
- [Decision Cycle](./decision-cycle.md) — The decision process
- [Arbitration](./arbitration.md) — Consensus strategies
- [Human Primacy](./human-primacy.md) — The foundational principle

---

## Sessions


A **session** is an instance of a state machine that specialists navigate through decision cycles.

## What Is a Session?

Think of a session as a "live" workflow being processed. It has:

- A **machine definition** — The blueprint defining possible states and transitions
- A **current state** — Where the session is right now
- A **session ID** — A unique UUID generated at creation
- A **creation timestamp** — When the session was started

```mermaid
graph LR
    subgraph Session
        D[Machine Definition]
        C[Current State]
        I[Session ID]
        T[Created At]
    end
```

## Session Lifecycle

### 1. Creation

A session starts with the `createSession` function:

```typescript
import { createSession } from "dialai";
import type { MachineDefinition } from "dialai";

const machine: MachineDefinition = {
  sessionTypeName: "document-review",
  initialState: "pending",
  defaultState: "approved",
  states: {
    pending: {
      prompt: "Review the document and decide: approve or request changes.",
      transitions: {
        approve: "approved",
        request_changes: "needs_revision",
      },
    },
    needs_revision: {
      prompt: "Review the revised document. Has the author addressed the feedback?",
      transitions: {
        approve: "approved",
        request_more_changes: "needs_revision",
      },
    },
    approved: {},
  },
};

const session = createSession(machine);
// session.sessionId     → "a1b2c3d4-..."
// session.currentState  → "pending"
// session.createdAt     → Date
```

The session is created in its `initialState`.

### 2. Progression

When a session is **not in its default state**, the decision cycle activates:

1. Specialists propose transitions
2. Proposals are compared through voting (if 2+)
3. Consensus is evaluated
4. The winning transition executes

### 3. Completion

A session is "complete" when it reaches its **`defaultState`**. The default state represents the goal — the stable configuration where no further action is needed.

## Machine Definition

Each session has a `MachineDefinition` that defines its structure:

```typescript
interface MachineDefinition {
  sessionTypeName: string;
  initialState: string;
  defaultState: string;
  states: Record<string, {
    prompt?: string;
    transitions?: Record<string, string>;
  }>;
}
```

### Fields

| Field | Description |
|-------|-------------|
| `sessionTypeName` | Identifies the type of session (e.g., `"document-review"`) |
| `initialState` | The state a session starts in |
| `defaultState` | The goal state — session is complete when it reaches this |
| `states` | A record of state names to their configuration |

### State Configuration

Each state can have:
- **`prompt`** — A description of the decision to be made in this state. Given to specialists to guide their proposals.
- **`transitions`** — A map of transition names to target states. If omitted, the state is terminal (no outgoing transitions).

### Decision Prompts

Each state's `prompt` describes the decision to be made. This prompt is:
- Given to all specialists (AI and human)
- Specialist-agnostic (same instructions for everyone)
- The source of truth for how to decide

## Querying Sessions

```typescript
import { getSession, getSessions } from "dialai";

// Get a specific session by ID
const session = getSession("a1b2c3d4-...");

// Get all sessions
const allSessions = getSessions();
```

## Session Types

A **session type** identifies which kind of machine is being run:

```typescript
sessionTypeName: "document-review"
sessionTypeName: "code-review"
sessionTypeName: "support-ticket"
```

Different session types have:
- Different machine definitions
- Different registered specialists

## Best Practices

### 1. Design Clear Default States

The default state should represent "done" or "stable":
- `approved`, `completed`, `resolved`
- Not `processing`, `in_progress`, `waiting`

### 2. Use Descriptive Decision Prompts

Good prompts are specific and actionable:

```
"Review the code changes. Check for: 1) correctness, 2) test coverage,
 3) documentation. Approve if all criteria met, otherwise request changes."

Not: "Decide what to do next."
```

### 3. Name Transitions Clearly

Transition names should describe the action being taken:

```typescript
transitions: {
  approve: "approved",        // Clear action
  request_changes: "needs_revision",
  reject: "rejected",
}
```

## Next Steps

- [Specialists](./specialists.md) — Learn about the actors that navigate sessions
- [Decision Cycle](./decision-cycle.md) — Understand how decisions are made

---

## Specialists


Specialists are the "pluggable" actors that participate in sessions. They can be AI models or humans.

## Roles

### Proposers

Proposers analyze the current state and suggest what transition should happen next. Any number of proposers can participate. A proposer's strategy function receives the current state name and available transitions, and returns a proposed transition.

### Voters

Voters evaluate proposals and express preferences between them. They compare pairs of proposals and vote for A, B, BOTH, or NEITHER. A voter's strategy function receives two proposals and returns a vote choice.

### Arbiters

Arbitration is built into the framework via the `evaluateConsensus` function. It uses weighted voting with human override.

## Human vs AI Specialists

**Human specialists** are identified by including "human" (case-insensitive) anywhere in their `specialistId` (e.g., `human-reviewer`, `specialist.human.jane`). When a human specialist votes, their choice wins immediately — no further vote tallying is needed.

**AI specialists** participate through weighted voting. The default weight is 1.0, set via the `weight` option during registration.

## Registering a Specialist

```typescript
import { registerSpecialist } from "dialai";

// Register a proposer with an inline strategy
registerSpecialist({
  specialistId: "ai-proposer-1",
  sessionTypeName: "my-task",
  role: "proposer",
  weight: 1.0,
  strategy: (currentState, transitions) => {
    const name = Object.keys(transitions)[0];
    return {
      transitionName: name,
      toState: transitions[name],
      reasoning: "First available transition",
    };
  },
});

// Register a voter
registerSpecialist({
  specialistId: "ai-voter-1",
  sessionTypeName: "my-task",
  role: "voter",
  weight: 1.0,
  strategy: (proposalA, proposalB) => {
    return {
      voteFor: "A",
      reasoning: "Proposal A moves closer to the goal",
    };
  },
});
```

### Registration Options

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `specialistId` | `string` | Yes | Unique identifier. Include "human" for human specialists. |
| `sessionTypeName` | `string` | Yes | Which session type this specialist participates in |
| `role` | `"proposer" \| "voter" \| "arbiter"` | Yes | The specialist's role |
| `weight` | `number` | No | Voting weight (default: 1.0) |
| `strategy` | `ProposerStrategy \| VoterStrategy` | Yes | The strategy function |

---

## Examples


This section contains example implementations demonstrating DialAI usage.

## Simple Machine

The repository includes a minimal example at `examples/simple-machine.json`:

```json
{
  "sessionTypeName": "simple-task",
  "initialState": "pending",
  "defaultState": "done",
  "states": {
    "pending": {
      "prompt": "Should we complete this task?",
      "transitions": { "complete": "done" }
    },
    "done": {}
  }
}
```

Run it with the CLI:

```bash
node dist/dialai/cli.js examples/simple-machine.json
```

Output:
```
Session type:  simple-task
Initial state: pending
Goal state:    done
Final state:   done
Session ID:    a1b2c3d4-...
```

## Programmatic Usage

```typescript
import { runSession } from "dialai";
import type { MachineDefinition } from "dialai";

const machine: MachineDefinition = {
  sessionTypeName: "simple-task",
  initialState: "pending",
  defaultState: "done",
  states: {
    pending: {
      prompt: "Should we complete this task?",
      transitions: { complete: "done" },
    },
    done: {},
  },
};

const session = runSession(machine);
console.log(session.currentState); // "done"
```

## Multi-Step Machine

A 3-state machine that requires 2 cycles to reach the goal:

```typescript
const pipeline: MachineDefinition = {
  sessionTypeName: "pipeline",
  initialState: "queued",
  defaultState: "complete",
  states: {
    queued: {
      prompt: "Start processing?",
      transitions: { start: "processing" },
    },
    processing: {
      prompt: "Processing complete. Finalize?",
      transitions: { finalize: "complete" },
    },
    complete: {},
  },
};

const session = runSession(pipeline);
// queued → processing → complete
```

## Custom Specialists Example

```typescript
import {
  createSession,
  registerSpecialist,
  solicitProposal,
  solicitVote,
  evaluateConsensus,
  executeTransition,
  clear,
} from "dialai";
import type { MachineDefinition } from "dialai";

clear(); // Reset state

const machine: MachineDefinition = {
  sessionTypeName: "review",
  initialState: "pending",
  defaultState: "approved",
  states: {
    pending: {
      transitions: {
        approve: "approved",
        reject: "rejected",
        revise: "pending",
      },
    },
    approved: {},
    rejected: {},
  },
};

// Two proposers that disagree
registerSpecialist({
  specialistId: "optimist",
  sessionTypeName: "review",
  role: "proposer",
  strategy: () => ({
    transitionName: "approve",
    toState: "approved",
    reasoning: "Looks good to me",
  }),
});

registerSpecialist({
  specialistId: "pessimist",
  sessionTypeName: "review",
  role: "proposer",
  strategy: () => ({
    transitionName: "reject",
    toState: "rejected",
    reasoning: "Needs more work",
  }),
});

// A voter that prefers approval
registerSpecialist({
  specialistId: "tiebreaker",
  sessionTypeName: "review",
  role: "voter",
  strategy: (proposalA, proposalB) => {
    if (proposalA.toState === "approved") return { voteFor: "A", reasoning: "Approve" };
    if (proposalB.toState === "approved") return { voteFor: "B", reasoning: "Approve" };
    return { voteFor: "NEITHER", reasoning: "Neither approves" };
  },
});

const session = createSession(machine);

// Solicit from both proposers
const p1 = solicitProposal(session.sessionId, "optimist");
const p2 = solicitProposal(session.sessionId, "pessimist");

// Solicit vote
solicitVote(session.sessionId, "tiebreaker", p1.proposalId, p2.proposalId);

// Evaluate and execute
const result = evaluateConsensus(session.sessionId);
if (result.consensusReached && result.winningProposalId) {
  const winner = [p1, p2].find((p) => p.proposalId === result.winningProposalId)!;
  executeTransition(session.sessionId, winner.transitionName, winner.toState, result.reasoning);
}

console.log(session.currentState); // "approved"
```

---

## Installation


Get DIAL up and running in your project.

## Prerequisites

- **Node.js** 18+ (LTS recommended)
- **npm** or **pnpm** or **yarn**
- **TypeScript** 5.0+ (recommended)

## Quick Install

```bash
# Using npm
npm install dialai

# Using pnpm
pnpm add dialai

# Using yarn
yarn add dialai
```

## Project Setup

### 1. Initialize a New Project

If you're starting fresh:

```bash
mkdir my-dial-project
cd my-dial-project
npm init -y
npm install dialai typescript @types/node tsx
npx tsc --init
```

### 2. Configure TypeScript

Ensure your `tsconfig.json` includes:

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "outDir": "./dist"
  },
  "include": ["src/**/*"]
}
```

### 3. Add `"type": "module"` to package.json

DIAL is an ESM package:

```json
{
  "type": "module"
}
```

## Verify Installation

Create a test file to verify everything works:

```typescript
// src/test-install.ts
import { createSession, runSession } from "dialai";
import type { MachineDefinition } from "dialai";

const machine: MachineDefinition = {
  sessionTypeName: "test",
  initialState: "start",
  defaultState: "end",
  states: {
    start: { transitions: { finish: "end" } },
    end: {},
  },
};

const session = runSession(machine);
console.log("DIAL installed successfully!");
console.log("Session reached:", session.currentState); // "end"
```

Run it:

```bash
npx tsx src/test-install.ts
```

You should see:
```
DIAL installed successfully!
Session reached: end
```

## CLI Usage

DIAL includes a CLI that runs a machine JSON file to completion:

```bash
npx dialai machine.json
```

See [Quick Start](./quick-start.md) for a full example.

## What's Next?

Now that DIAL is installed, you're ready to:

1. **[Quick Start](./quick-start.md)** — Build your first state machine with AI and human specialists
2. **[Learn Concepts](../concepts/intro.md)** — Understand sessions, specialists, and decision cycles
3. **[Build State Machines](../guides/state-machines.md)** — Model your tasks as state machines

## Troubleshooting

### "Module not found" errors

Ensure you're using a compatible Node.js version:

```bash
node --version  # Should be 18+
```

### TypeScript compilation errors

Make sure your tsconfig uses `NodeNext` module resolution:

```json
{
  "compilerOptions": {
    "module": "NodeNext",
    "moduleResolution": "NodeNext"
  }
}
```

### ESM/CJS issues

DIAL is an ESM package. If you're in a CommonJS project, either:

1. Add `"type": "module"` to your `package.json`, or
2. Use dynamic imports:

```typescript
const { runSession } = await import("dialai");
```

### Need help?

- Check the [GitHub Issues](https://github.com/eloquentanalytics/dialai/issues)
- Search existing discussions
- Open a new issue with your error details

---

## Quick Start


Build your first DIAL state machine with specialists.

## What We'll Build

A trivially simple machine that asks "Is 2 > 1?" and transitions from `unsure` to `sure` regardless of the answer:

```mermaid
stateDiagram-v2
    [*] --> unsure
    unsure --> sure: yes
    unsure --> sure: no
    sure --> [*]
```

## Step 1: Define the Machine

Save this as `examples/simple-machine.json`:

```json
{
  "sessionTypeName": "is-two-greater",
  "initialState": "unsure",
  "defaultState": "sure",
  "states": {
    "unsure": {
      "prompt": "Is 2 > 1?",
      "transitions": { "yes": "sure", "no": "sure" }
    },
    "sure": {}
  }
}
```

- **`initialState`** — where the session starts (`unsure`)
- **`defaultState`** — the goal state where the machine comes to rest (`sure`)
- **`prompt`** — the question specialists answer when the session is in that state
- **`transitions`** — the available answers and what state each leads to

Both `yes` and `no` lead to `sure`, so the machine always resolves in one cycle.

Or define the same thing in TypeScript:

```typescript
import type { MachineDefinition } from "dialai";

const machine: MachineDefinition = {
  sessionTypeName: "is-two-greater",
  initialState: "unsure",
  defaultState: "sure",
  states: {
    unsure: {
      prompt: "Is 2 > 1?",
      transitions: { yes: "sure", no: "sure" },
    },
    sure: {},
  },
};
```

## Step 2: Run It

The quickest way to run a machine is with `runSession`, which registers a built-in proposer that picks the first available transition:

```typescript
import { runSession } from "dialai";

const session = runSession(machine);

console.log(session.currentState); // "sure"
```

That's it — one cycle, done.

## Step 3: Add a Human Specialist

The real point of DIAL is that humans can participate. Let's walk through the full API to see how a human votes `yes`.

```typescript
import {
  createSession,
  submitProposal,
  submitVote,
  evaluateConsensus,
  executeTransition,
} from "dialai";

// Create a session — starts in "unsure"
const session = createSession(machine);
console.log(session.currentState); // "unsure"

// Two specialists each submit a proposal
const proposalYes = submitProposal(
  session.sessionId,
  "ai-specialist",
  "yes",
  "sure",
  "2 is obviously greater than 1"
);

const proposalNo = submitProposal(
  session.sessionId,
  "contrarian-ai",
  "no",
  "sure",
  "I just like being difficult"
);

// A human votes for "yes" (proposal A)
submitVote(
  session.sessionId,
  "human-reviewer",
  proposalYes.proposalId,
  proposalNo.proposalId,
  "A",
  "Yes, 2 is greater than 1"
);

// Evaluate consensus — human votes win immediately
const consensus = evaluateConsensus(session.sessionId);
console.log(consensus.consensusReached); // true
console.log(consensus.reasoning);        // "The human preferred: sure"

// Execute the winning transition, recording the arbiter's reasoning
executeTransition(session.sessionId, "yes", "sure", consensus.reasoning);
console.log(session.currentState); // "sure"
console.log(session.history);      // [{ fromState: "unsure", toState: "sure", reasoning: "The human preferred: sure", ... }]
```

Because the specialist ID `"human-reviewer"` contains "human", `evaluateConsensus` gives their vote priority. This is **human primacy** — humans always get the final say.

## Step 4: Use the CLI

Run a machine definition from the command line:

```bash
node dist/dialai/cli.js examples/simple-machine.json
```

Output:
```
Session type:  is-two-greater
Initial state: unsure
Goal state:    sure
Final state:   sure
Session ID:    a1b2c3d4-...
```

## What's Happening Under the Hood

1. **Session created** in `initialState` (`unsure`)
2. **Proposers solicited** — each returns a proposed transition (`yes` or `no`)
3. **Votes solicited** (if 2+ proposals) — pairwise comparisons
4. **Consensus evaluated** — human votes override; otherwise weighted ahead-by-k
5. **Transition executed** — `currentState` moves to `sure`, proposals/votes cleared
6. **Cycle repeats** until `currentState === defaultState` (already there — done)

## Next Steps

- **[State Machines](../guides/state-machines.md)** — Design more complex workflows
- **[Registering Specialists](../guides/registering-specialists.md)** — Configure specialists with strategies
- **[Implementing Strategies](../guides/implementing-strategies.md)** — Customize strategy functions
- **[Concepts](../concepts/intro.md)** — Deep dive into DIAL's architecture

---

## Implementing Strategies


Strategies are functions that define how specialists make decisions. Each specialist is registered with a strategy function that gets called during the decision cycle.

## Proposer Strategy

A proposer strategy receives the current state name and available transitions, and returns a transition choice:

```typescript
import type { ProposerStrategy } from "dialai";

const myProposer: ProposerStrategy = (currentState, transitions) => {
  // currentState: string — the session's current state name
  // transitions: Record<string, string> — maps transition name → target state

  // Your logic here: call an LLM, apply rules, etc.

  return {
    transitionName: "complete",
    toState: "done",
    reasoning: "Task is ready to be completed",
  };
};
```

### ProposerStrategy Type

```typescript
type ProposerStrategy = (
  currentState: string,
  transitions: Record<string, string>
) => {
  transitionName: string;
  toState: string;
  reasoning: string;
};
```

### Example: Pick the First Transition

```typescript
const firstTransition: ProposerStrategy = (_currentState, transitions) => {
  const name = Object.keys(transitions)[0];
  return {
    transitionName: name,
    toState: transitions[name],
    reasoning: "First available transition",
  };
};
```

### Example: Goal-Directed Proposer

```typescript
const goalDirected: ProposerStrategy = (_currentState, transitions) => {
  // Prefer transitions that lead to the goal state
  for (const [name, target] of Object.entries(transitions)) {
    if (target === "done" || target === "approved" || target === "completed") {
      return {
        transitionName: name,
        toState: target,
        reasoning: `Transition "${name}" leads directly to goal state "${target}"`,
      };
    }
  }
  // Fallback to first transition
  const name = Object.keys(transitions)[0];
  return {
    transitionName: name,
    toState: transitions[name],
    reasoning: "No direct path to goal; taking first available transition",
  };
};
```

## Voter Strategy

A voter strategy compares two proposals and returns a preference:

```typescript
import type { VoterStrategy } from "dialai";

const myVoter: VoterStrategy = (proposalA, proposalB) => {
  // proposalA, proposalB: Proposal objects with:
  //   proposalId, sessionId, specialistId, transitionName, toState, reasoning

  // Your logic to compare proposals

  return {
    voteFor: "A", // "A" | "B" | "BOTH" | "NEITHER"
    reasoning: "Proposal A better aligns with the decision criteria",
  };
};
```

### VoterStrategy Type

```typescript
type VoterStrategy = (
  proposalA: Proposal,
  proposalB: Proposal
) => {
  voteFor: VoteChoice; // "A" | "B" | "BOTH" | "NEITHER"
  reasoning: string;
};
```

### Example: Prefer Goal-Reaching Proposals

```typescript
const goalVoter: VoterStrategy = (proposalA, proposalB) => {
  const aReachesGoal = proposalA.toState === "done";
  const bReachesGoal = proposalB.toState === "done";

  if (aReachesGoal && !bReachesGoal) {
    return { voteFor: "A", reasoning: "Proposal A reaches the goal state" };
  }
  if (bReachesGoal && !aReachesGoal) {
    return { voteFor: "B", reasoning: "Proposal B reaches the goal state" };
  }
  if (aReachesGoal && bReachesGoal) {
    return { voteFor: "BOTH", reasoning: "Both proposals reach the goal" };
  }
  return { voteFor: "NEITHER", reasoning: "Neither proposal reaches the goal" };
};
```

## Using Strategies with Specialists

Register strategies when creating specialists:

```typescript
import { registerSpecialist } from "dialai";

registerSpecialist({
  specialistId: "goal-proposer",
  sessionTypeName: "my-task",
  role: "proposer",
  strategy: goalDirected,
});

registerSpecialist({
  specialistId: "goal-voter",
  sessionTypeName: "my-task",
  role: "voter",
  strategy: goalVoter,
});
```

## Direct Submission

You can also bypass strategies and submit proposals or votes directly:

```typescript
import { submitProposal, submitVote } from "dialai";

// Submit a proposal without a registered strategy
const proposal = submitProposal(
  sessionId,
  "manual-proposer",
  "approve",
  "approved",
  "Manually approved after review"
);

// Submit a vote directly
const vote = submitVote(
  sessionId,
  "manual-voter",
  proposalA.proposalId,
  proposalB.proposalId,
  "A",
  "Prefer proposal A"
);
```

---

## Registering Specialists


Specialists are registered for a specific session type using the `registerSpecialist` function.

## Basic Registration

```typescript
import { registerSpecialist } from "dialai";

registerSpecialist({
  specialistId: "ai-proposer-1",
  sessionTypeName: "my-task",
  role: "proposer",
  strategy: (currentState, transitions) => {
    const name = Object.keys(transitions)[0];
    return {
      transitionName: name,
      toState: transitions[name],
      reasoning: "First available transition",
    };
  },
});
```

## Registration Options

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `specialistId` | `string` | Yes | — | Unique identifier for this specialist |
| `sessionTypeName` | `string` | Yes | — | Which session type this specialist participates in |
| `role` | `"proposer" \| "voter" \| "arbiter"` | Yes | — | The specialist's role |
| `weight` | `number` | No | `1.0` | Voting weight used in consensus evaluation |
| `strategy` | `ProposerStrategy \| VoterStrategy` | Yes | — | The strategy function |

## Specialist ID Conventions

Any naming scheme works, but including the role and purpose is helpful:

```
ai-proposer-1
ai-voter-gpt4
human-reviewer
human-approver-jane
```

To enable the human override in `evaluateConsensus`, include "human" (case-insensitive) anywhere in the `specialistId`:

```typescript
// These all trigger human primacy:
registerSpecialist({ specialistId: "human-reviewer", ... });
registerSpecialist({ specialistId: "specialist.human.jane", ... });
registerSpecialist({ specialistId: "HUMAN_APPROVER", ... });
```

## Proposer Specialists

A proposer's strategy receives the current state name and the available transitions map, and returns a transition choice:

```typescript
import type { ProposerStrategy } from "dialai";

const myProposer: ProposerStrategy = (currentState, transitions) => {
  // transitions is Record<string, string> — maps transition name → target state
  return {
    transitionName: "approve",
    toState: "approved",
    reasoning: "Document meets standards",
  };
};

registerSpecialist({
  specialistId: "smart-proposer",
  sessionTypeName: "document-review",
  role: "proposer",
  strategy: myProposer,
});
```

## Voter Specialists

A voter's strategy receives two proposals and returns a vote:

```typescript
import type { VoterStrategy } from "dialai";

const myVoter: VoterStrategy = (proposalA, proposalB) => {
  // proposalA and proposalB are Proposal objects with:
  //   proposalId, sessionId, specialistId, transitionName, toState, reasoning
  return {
    voteFor: "A", // "A" | "B" | "BOTH" | "NEITHER"
    reasoning: "Proposal A is more aligned with the goal",
  };
};

registerSpecialist({
  specialistId: "quality-voter",
  sessionTypeName: "document-review",
  role: "voter",
  strategy: myVoter,
});
```

## Human Specialists

Human specialists can be registered with strategy functions that encode human preferences, or proposals/votes can be submitted directly via `submitProposal` and `submitVote`:

```typescript
// Register a human specialist with a strategy
registerSpecialist({
  specialistId: "human-reviewer",
  sessionTypeName: "document-review",
  role: "voter",
  strategy: (proposalA, proposalB) => ({
    voteFor: "B",
    reasoning: "Prefer the more conservative approach",
  }),
});

// Or submit votes directly without a strategy
import { submitVote } from "dialai";

submitVote(
  session.sessionId,
  "human-reviewer",
  proposalA.proposalId,
  proposalB.proposalId,
  "B",
  "I prefer the more conservative approach"
);
```

## Weight Configuration

The `weight` parameter controls how much a specialist's vote counts during consensus evaluation:

```typescript
// Default weight is 1.0
registerSpecialist({
  specialistId: "standard-voter",
  sessionTypeName: "my-task",
  role: "voter",
  weight: 1.0,
  strategy: myVoter,
});

// Higher weight = more influence
registerSpecialist({
  specialistId: "senior-voter",
  sessionTypeName: "my-task",
  role: "voter",
  weight: 2.0,
  strategy: myVoter,
});
```

Note: Human vote override ignores weights entirely — if a specialist's ID contains "human", their vote wins immediately regardless of weight.

---

## State Machines


State machines define the structure of your sessions. Each session type has its own machine definition.

## Defining a Machine

A `MachineDefinition` defines:

- `sessionTypeName` — identifies the type
- `initialState` — where sessions start
- `defaultState` — the goal state (session is complete when it reaches this)
- `states` — a record of state names to their configuration

## Example

```typescript
import type { MachineDefinition } from "dialai";

const myMachine: MachineDefinition = {
  sessionTypeName: "my-task",
  initialState: "idle",
  defaultState: "done",
  states: {
    idle: {
      prompt: "The system is idle. What should happen next?",
      transitions: {
        start: "working",
        configure: "configuring",
      },
    },
    configuring: {
      prompt: "Configuration in progress. Apply or cancel?",
      transitions: {
        apply: "working",
        cancel: "idle",
      },
    },
    working: {
      prompt: "The system is working. Should it continue or finish?",
      transitions: {
        finish: "done",
        reconfigure: "configuring",
      },
    },
    done: {},
  },
};
```

## Machine Definition as JSON

Machines can also be defined as plain JSON files, useful with the CLI:

```json
{
  "sessionTypeName": "simple-task",
  "initialState": "pending",
  "defaultState": "done",
  "states": {
    "pending": {
      "prompt": "Should we complete this task?",
      "transitions": { "complete": "done" }
    },
    "done": {}
  }
}
```

Run with the CLI:

```bash
node dist/dialai/cli.js my-machine.json
```

## State Configuration

Each state in the `states` record can have:

### `prompt` (optional)

A string describing the decision to be made in this state. This prompt guides specialists in choosing which transition to propose.

```typescript
states: {
  reviewing: {
    prompt: "Review the document. Approve if quality standards are met, otherwise request changes.",
    transitions: { approve: "approved", request_changes: "needs_revision" },
  },
}
```

### `transitions` (optional)

A record mapping transition names to target state names. If omitted, the state has no outgoing transitions (terminal state).

```typescript
transitions: {
  approve: "approved",        // transition "approve" → state "approved"
  request_changes: "needs_revision",
}
```

## Design Patterns

### Linear Workflow

```typescript
const linear: MachineDefinition = {
  sessionTypeName: "pipeline",
  initialState: "step1",
  defaultState: "complete",
  states: {
    step1: { transitions: { next: "step2" } },
    step2: { transitions: { next: "step3" } },
    step3: { transitions: { next: "complete" } },
    complete: {},
  },
};
```

### Review Loop

```typescript
const reviewLoop: MachineDefinition = {
  sessionTypeName: "review",
  initialState: "draft",
  defaultState: "published",
  states: {
    draft: {
      prompt: "Review the draft. Approve or request revisions?",
      transitions: {
        approve: "published",
        revise: "revising",
      },
    },
    revising: {
      prompt: "Revisions made. Submit for review?",
      transitions: { submit: "draft" },
    },
    published: {},
  },
};
```

### Branching Decisions

```typescript
const branching: MachineDefinition = {
  sessionTypeName: "triage",
  initialState: "incoming",
  defaultState: "resolved",
  states: {
    incoming: {
      prompt: "Triage this ticket: escalate, handle directly, or close?",
      transitions: {
        escalate: "escalated",
        handle: "in_progress",
        close: "resolved",
      },
    },
    escalated: {
      transitions: { resolve: "resolved" },
    },
    in_progress: {
      transitions: { resolve: "resolved", escalate: "escalated" },
    },
    resolved: {},
  },
};
```

## Decision Prompts

Each state's `prompt` describes how to decide what to do next. Good prompts are:

- **Specific** — List the available choices and criteria
- **Actionable** — Tell the specialist what to evaluate
- **Consistent** — Same instructions for all specialists (AI and human)

```
Good: "Review the code changes. Check for: 1) correctness, 2) test coverage,
      3) documentation. Approve if all criteria met, otherwise request changes."

Bad:  "Decide what to do next."
```

---

## Introduction to DIAL


**DIAL** (Dynamic Integration between AI and Labor) is a coordination framework for AI and human specialists making decisions together within state machines.

## Why DIAL?

The promise of AI is efficiency—faster, cheaper execution of narrow tasks. But the question organizations face isn't "Can AI do this?" It's:

> **How do you know — in dollars, time, and quality — exactly what it would cost to turn any task over to a minimally competent AI decision-maker? And how involved should humans remain as quality control?**

DIAL provides the answer through **empirical measurement**, not speculation.

## The Core Insight

AI models are created by us. Their works are based on our works. They cannot be better than us because they can never have as large a context as we do.

An AI model operates on a bounded context window—thousands or millions of tokens. A human operates on a **lifetime of embodied experience**, tacit knowledge, institutional context, and real-time sensory input that no model has access to.

The human knows things they cannot tell the machine.

## Three Foundational Principles

### 1. Human Primacy

The human is always right—not because humans are infallible, but because humans have context that AI cannot access.

It is always safer for the AI to assume the human had reasons, just as it is safer for a child to defer to a parent—not because the parent is infallible, but because the parent has context the child cannot access.

An AI specialist should choose what the human would choose, even if its own reasoning disagrees. It will be judged on alignment with the human, and that judgment is correct.

### 2. Progressive Collapse

Over repeated decision cycles, measuring how well AI predicts human choices causes the multi-agent deliberation structure to **progressively collapse into deterministic execution**.

This collapse is emergent, not designed. As AI specialists prove their alignment with human judgment through accumulated data, the expensive deliberation process naturally simplifies.

### 3. Empirical Trust

Trust is earned through demonstrated alignment with human decisions, not assumed.

- **Human specialists** are identified by including "human" in their `specialistId` — their votes override all AI votes immediately
- **AI specialists** participate through weighted voting
- Trust is built through alignment with human choices over time

## What DIAL Is Not

DIAL is not about AI replacing humans. It's about discovering—with precise cost data—which decisions are narrow enough for AI to handle, and what the ongoing human quality-control cost is to maintain that delegation over time.

The value of AI is not superiority. **It is efficiency.** AI is faster and cheaper at narrow tasks where the required context fits within the model's window.

## How It Works

1. **Model the task as a state machine** — Define states, transitions, and decision prompts
2. **Register specialists** — Both AI and humans that can propose transitions and vote
3. **Run decision cycles** — Propose → Vote → Arbitrate → Execute
4. **Reach the goal state** — The session completes when it reaches its `defaultState`

```mermaid
graph LR
    A[Propose] --> B[Vote]
    B --> C[Arbitrate]
    C --> D[Execute]
    D --> A
```

## What's Next?

  
    
      
        🚀 Get Started
      
      
        Install DIAL and run your first state machine with AI and human specialists.
        Installation Guide →
      
    
  
  
    
      
        📚 Learn Concepts
      
      
        Understand sessions, specialists, decision cycles, and arbitration strategies.
        Explore Concepts →
      
    
  

## Key Terminology

| Term | Definition |
|------|------------|
| **Session** | An instance of a state machine being navigated by specialists |
| **Specialist** | A pluggable actor (AI or human) that proposes transitions or votes |
| **Decision Cycle** | The repeating process: Propose → Vote → Arbitrate → Execute |
| **Arbiter** | The built-in logic that evaluates consensus and determines when a proposal wins |
| **Weight** | A specialist's voting authority (default 1.0) |
| **Default State** | The goal state — the session is complete when it reaches this state |
