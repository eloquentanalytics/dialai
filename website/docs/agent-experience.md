---
sidebar_position: 2
---

# Agent Experience Development

DIAL is designed for LLM-driven agents as first-class participants. Every design decision optimizes for agents that need to understand, integrate with, and act within the framework autonomously: the API shape, the documentation format, and the way changelogs are written.

## Agents as Participants

The specialist abstraction exists so that LLM agents can register themselves as proposers and voters in a decision cycle. An agent reading a state machine definition can determine what state the session is in, what transitions are available, and what the prompt is asking. It can then submit a proposal or cast a vote using the same API a human would use.

This is the point. DIAL does not treat agents as a backend detail or an orchestration layer. Agents sit alongside humans in the decision cycle and are evaluated by the same arbiter under the same rules. The difference is that human votes override, because [human primacy](./concepts/human-primacy.md) is a safety constraint on the system.

## Spec-Driven Development

The source of truth for DIAL is its documentation. The code in `/src` is generated from the documentation files, not the other way around.

This means an agent reading the docs has the authoritative specification. If the docs say `executeTransition` accepts an optional `reasoning` parameter and records a `TransitionRecord` in `session.history`, that is what the implementation does. An agent does not need to read the TypeScript source to understand the contract. The docs are the contract.

This also means the docs are written with the precision an agent needs: exact function signatures, explicit parameter types, concrete return values. Prose explains intent. Code blocks define behavior.

## Changelogs as Instructions

Commit messages and changelogs in the DIAL repository are written as instructions to an LLM that is maintaining a codebase which depends on DIAL.

A conventional changelog entry tells a human what changed. A DIAL changelog entry tells an agent **what to do about it**:

- What the change is
- What call sites are affected
- What the migration path is
- What the new behavior looks like in code

This is a deliberate choice. The primary consumer of DIAL's change history is an agent that needs to update its integration. The writing style reflects that.

## Reference Implementations

DIAL ships reference implementations in TypeScript as CLI tools. The CLI accepts a machine definition as JSON and runs it to completion:

```bash
node dist/dialai/cli.js examples/simple-machine.json
```

```
Session type:  is-two-greater
Initial state: unsure
Goal state:    sure
Final state:   sure
Session ID:    a1b2c3d4-...
```

The CLI is minimal by design. It demonstrates the exact sequence of API calls an agent would make (create a session, register specialists, solicit proposals, evaluate consensus, execute transitions) in a form that is easy for an agent to read, replicate, and extend.

The help documentation and error messages are written for LLM comprehension. When the CLI fails, it says what went wrong and what the valid inputs are, in plain text that an agent can parse and act on.

## Documentation for Agents

DIAL documentation is served in two forms:

1. **Traditional web**: the Docusaurus site you are reading now, with structured navigation, code examples, and concept explanations
2. **llms.txt**: a machine-readable format generated by the [docusaurus-plugin-llms](https://github.com/signalwire/docusaurus-plugin-llms) plugin, which concatenates all documentation into a single text file optimized for LLM context windows

The `llms.txt` format allows an agent to ingest the entire DIAL specification in one read operation rather than navigating a site. Both formats contain the same information. The web form is organized for browsing. The `llms.txt` form is organized for ingestion.

## Tool-Oriented, Not Resource-Oriented

DIAL's API is **tool-oriented** rather than resource-oriented. The distinction matters for agents.

A resource-oriented API exposes data: "here is a session, here are its proposals, here are its votes." An agent working with a resource-oriented API must figure out the correct sequence of reads and writes to accomplish a goal.

A tool-oriented API exposes actions: `submitProposal`, `submitVote`, `evaluateConsensus`, `executeTransition`. Each function is a discrete action with a clear purpose. An agent with tool-use capabilities can map these directly to its tool-calling interface.

The 10 functions in the DIAL API are designed to be the 10 tools an agent needs:

| Function | Action |
|---|---|
| `createSession` | Start a new decision process |
| `getSession` | Check the current state |
| `getSessions` | List all active processes |
| `registerSpecialist` | Join a decision process as a participant |
| `submitProposal` | Propose a transition |
| `solicitProposal` | Ask a specialist's strategy to propose |
| `submitVote` | Cast a vote between two proposals |
| `solicitVote` | Ask a specialist's strategy to vote |
| `evaluateConsensus` | Check if the group has reached agreement |
| `executeTransition` | Apply the winning proposal |

An agent calling `submitProposal(sessionId, myId, "approve", "approved", "Document meets quality standards")` is doing exactly one thing: proposing a state transition. There is no ambiguity about what the call does, what it returns, or what happens next.

This is agent experience development. The framework is built so that the agent's path from "I have a task" to "I took an action" is as short and unambiguous as possible.

## The Constitution

DIAL publishes a [Constitution](/constitution), a detailed description of how AI specialists should reason and behave within the framework. It is not a policy document for humans. It is written with the specialist as its primary audience, optimized for precision over accessibility, because a specialist needs to be able to cite it during reasoning.

### Why a Constitution Matters

An LLM acting as a DIAL specialist faces a specific problem: it needs to know what "good behavior" means before it encounters any particular decision. The constitution solves this by defining a priority hierarchy (alignment with humans first, faithfulness to the prompt second, honesty third, usefulness fourth), hard constraints (no fabrication, no coordination between specialists, no manipulating the arbiter), and concrete guidance for making proposals and casting votes.

Without the constitution, every specialist would invent its own interpretation of what DIAL expects. The system's measurements would reflect inconsistent reasoning rather than genuine alignment differences.

### Using the Constitution as a System Prefix

We encourage any agent acting as a DIAL specialist to prefix its system prompt with the constitution text. The constitution is designed for exactly this use: it fits within a context window, it uses precise language an LLM can follow, and every principle is structured so the specialist can trace a decision back to a specific section.

A specialist that has internalized the constitution will:

- Defer to demonstrated human preferences over its own reasoning
- Express calibrated confidence rather than fabricating conviction
- Reflect human-like variance in its output probabilities rather than collapsing to a single answer with artificial certainty
- Submit NULL proposals or vote NEITHER when genuinely uncertain
- Cite the decision prompt and session history as evidence, not its own independent analysis

This is also how we use the constitution in fine-tuning. Training data for DIAL specialists is evaluated against the constitution's priority hierarchy. The constitution defines what correct means, and correct means aligned with the human.

The full text is available at [/constitution](/constitution).

## Spec Change Workflow

When a specification is updated, the change propagates through the codebase in a fixed order. This order is mandatory.

1. **Update the tests**: The spec changed, so the tests must change first. Write or modify tests that assert the new behavior described in the updated docs. These tests will fail. That is correct.
2. **Update the implementation**: Modify the code in `/src` until the new tests pass and no existing tests regress.
3. **Run the tests against the example machines**: Execute every machine definition in `/examples` through the CLI and programmatic API. The examples are integration tests. If a spec change breaks an example, the example is wrong, not the spec.
4. **Fix the example machines**: Update any example that fails to conform to the new spec. Record what changed in each example and why.
5. **Synthesize and write the changelog**: Combine the spec change, the implementation change, and the example fixes into a single changelog entry. Write it as an instruction to an agent that depends on DIAL: what changed, what breaks, what to do about it.

Each change like this is a **branch**. The branch contains a series of commits following the steps above. When the branch is merged, the merge commit carries the changelog message and a version bump.

### Versioning

The current version is tracked in `VERSION.md` at the repository root. The format is a single line containing the semantic version number. The merge commit that closes a spec change branch increments the version:

- **Patch**: bug fixes, example corrections, doc clarifications that do not change behavior
- **Minor**: new functions, new parameters, new fields on existing types
- **Major**: removed functions, changed return types, changed parameter semantics

The version in `VERSION.md` is the version. There is no `package.json` version to keep in sync, no release script to run. An agent reading `VERSION.md` knows what version of the spec the codebase implements.
