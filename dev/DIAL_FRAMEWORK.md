# DIAL Framework — Technical Reference

For conceptual overview, see [DIAL_CONCEPTS.md](./DIAL_CONCEPTS.md).

---

## Common Parameters

### Server-Generated Fields

The following fields are **always generated by the server** when processing a command. They are never accepted as API input:

- `commandCorrelationId` (string, UUID) - Generated by the server to correlate commands with their resulting events. The CLI uses this to operate asynchronously: a command is inserted into the sync stream, then the CLI waits for an event with the same `commandCorrelationId` to appear.
- `receivedAtTimestamp` (string, ISO 8601) - Timestamp when the server received the command.

### Parameter Sections

Each command/event pair below documents:
- **API Input**: Parameters accepted by the HTTP endpoint (what clients send)
- **Stored Command**: Parameters recorded in the event stream for the command (API input + server-generated fields)
- **Event Parameters**: Parameters in the resulting event (all stored command params EXCEPT `receivedAtTimestamp` + event-specific fields). Note: `receivedAtTimestamp` is server metadata and is not included in events. Events include `commandCorrelationId` which can be used to look up the command's `receivedAtTimestamp` from the `commands` table if needed.

## Schema Duplication

Schemas are defined twice: Zod (`src/types/*.ts`) for server-side API validation, and LiveStore Effect Schema (`src/livestore/schema.ts`) for client-side sync, materializations, and tests. Both are required—they serve different runtimes. Changes to command/event structures must be updated in both places.

## Sync Architecture

The server implements the sync protocol (`/sync/push`, `/sync/pull`) with Postgres storage. Clients use LiveStore to sync events and materialize them locally in SQLite. The server does not use LiveStore—it implements the backend that LiveStore clients connect to.

## Implementation-Defined Fields (Opaque to Framework)

Certain fields are **opaque containers**—the DIAL framework stores, routes, and matches on them but has no awareness of their contents or semantics. The implementation defines their structure and meaning.

### Data Containers

These JSON string fields hold arbitrary implementation-specific data:

- `metadataJSONString` - Session-level metadata (e.g., user preferences, external references). Passed at session creation, stored unchanged.
- `currentParamsJSONString` / `toParamsJSONString` - State parameters. `currentParamsJSONString` is the current state's params; `toParamsJSONString` is an opaque container included in proposals and executed transitions. The framework stores and routes these values but doesn't interpret their contents.

### Identity Fields

These string fields are matched by equality but their meaning is implementation-defined:

- `machineName` - Identifies which state machine definition to use. The framework validates it exists but doesn't understand what it represents.
- `specialistId` - Identifies a specialist (human or AI agent). The framework routes solicitations and tracks proposals/votes by this ID. **Human specialists are identified by including "human" (case-insensitive) anywhere in their specialistId** (e.g., `specialist.sheep.human`, `human_operator_1`). Human votes have weight 1.0 by default; LLM votes start at weight 0.0 and are scaled by the risk dial.
- `transitionName` / `toStateName` - Identifies transitions and target states in the state machine.

---

## Specialist Strategies

All specialist roles are implemented as pluggable strategies loaded from `./strategies/{machineName}/{strategyFunctionKey}.ts`.

**Solicitation**: Only proposers and voters are solicited via commands. Arbiters and tools are invoked directly by the framework when needed.

### Resolution

1. Look up `specialistId` in `specialists` table
2. If found: load strategy from `./strategies/{machineName}/{strategyFunctionKey}.ts`
3. If not found: use pure function specialist from session type registration

### Proposer Strategy Interface

**Input (`ProposalDecisionInput`):**
- `prompt` (string) - From XState machine's `meta.prompt` for the current state
- `eventStream` (SessionEvent[]) - Full event history for the session
- `modelId` (string) - Model identifier from specialist registration

**Output:** `SubmitProposalCommand`. The framework adds `sessionId`, `specialistId`, and `fromTransitionExecutionId`.

**Contract:** Always return a command. To decline, set `transitionName` and `toStateName` to null and explain in `reasoning`.

### Voter Strategy Interface

**Input (`VoteDecisionInput`):**
- `prompt` (string) - From XState machine's `meta.prompt` for the current state
- `eventStream` (SessionEvent[]) - Full event history for the session
- `proposalA`, `proposalB` - The two proposals to compare
- `modelId` (string) - Model identifier from specialist registration

**Output:** `SubmitVoteCommand`. The framework adds `sessionId`, `specialistId`, `proposalIdA`, `proposalIdB`.

### Arbiter Strategy Interface

**Input (`ArbiterDecisionInput`):**
- `proposals` (Proposal[]) - All proposals for this round
- `votes` (Vote[]) - All votes cast
- `riskDial` (number) - State-level risk configuration

**Output:** `{ consensusReached: boolean, winningProposalId?: string, reasoning: string }`

### Tool Strategy Interface

**Input (`ToolInvocationInput`):**
- `prompt` (string) - From XState machine's `meta.prompt` for the current state
- `currentState` - Current state name and params

**Output:** `ExecuteTransitionCommand`. The framework adds `sessionId`.

---

### command.start_session -> event.session_started

Create a new session.

API Input:
- `machineName` (string, must match a known session type or returns 400)
- `metadataJSONString` (string, optional)
- `initialParamsJSONString` (string, optional) - Override the machine's initial params

Stored Command (API input + server-generated):
- `commandCorrelationId` (string, UUID)
- `machineName` (string)
- `metadataJSONString` (string, optional)
- `initialParamsJSONString` (string, optional)
- `receivedAtTimestamp` (string, ISO 8601)

Event Parameters:
- All parameters from the stored command, plus:
- `sessionId` (string, UUID)
- `startedAtTimestamp` (string, ISO 8601)
- `currentStateName` (string, optional)
- `currentParamsJSONString` (string, optional)

Materializations:
- `sessions`: Upsert into this table based on the `sessionId`. Updated by `event.session_started` and `event.transition_executed`. Represents current session state.

### command.submit_proposal -> event.proposal_submitted

Propose a transition for a session.

API Input:
- `sessionId` (string, UUID)
- `specialistId` (string, UUID)
- `transitionName` (string)
- `toStateName` (string) - The target state name after the transition
- `toParamsJSONString` (string, optional) - Opaque JSON string containing parameters for the target state. The framework stores this value but doesn't interpret its contents.
- `fromTransitionExecutionId` (string, UUID, optional, defaults to the `transitionExecutionId` of the most recent `event.transition_executed` event for the session) - The transition execution ID (eventId of the last `event.transition_executed` event) that represents the state the machine was in when this proposal was made. This links the proposal to a specific point in the state machine's history, enabling replay of events up to that transition for testing new models. If null, the proposal was made at the initial state (before any transitions were executed).
- `reasoning` (string, optional) - Explanation of why this transition was proposed.
- `costUSD` (number, optional) - Cost in USD to generate this proposal.
- `latencyMsec` (number, optional) - Time in milliseconds to generate this proposal.
- `numInputTokens` (number, optional) - Number of input tokens used to generate this proposal.
- `numOutputTokens` (number, optional) - Number of output tokens used to generate this proposal.

Stored Command (API input + server-generated):
- `commandCorrelationId` (string, UUID)
- All API input fields
- `receivedAtTimestamp` (string, ISO 8601)

Event Parameters:
- All parameters from the stored command, plus:
- `proposalId` (string, UUID)
- `proposedAtTimestamp` (string, ISO 8601)

Materializations:
- `proposals`: Upsert into this table based on the `proposalId`. The fields should be the same as the `event.proposal_submitted` event. This table allows a simple way to represent the current state of the proposal.

### command.submit_vote -> event.vote_submitted

Vote to express a preference between two proposals, either to prefer one over the other, or both or neither.

Validation: Both proposals must have the same `fromTransitionExecutionId`.

API Input:
- `sessionId` (string, UUID)
- `specialistId` (string, UUID)
- `proposalIdA` (string, UUID)
- `proposalIdB` (string, UUID)
- `voteFor` (string, enum, [A|B|BOTH|NEITHER])
- `reasoning` (string, optional) - Explanation of why this vote was cast.
- `costUSD` (number, optional) - Cost in USD to generate this vote.
- `latencyMsec` (number, optional) - Time in milliseconds to generate this vote.
- `numInputTokens` (number, optional) - Number of input tokens used to generate this vote.
- `numOutputTokens` (number, optional) - Number of output tokens used to generate this vote.

Stored Command (API input + server-generated):
- `commandCorrelationId` (string, UUID)
- All API input fields
- `receivedAtTimestamp` (string, ISO 8601)

Event Parameters:
- All parameters from the stored command, plus:
- `voteId` (string, UUID)
- `votedAtTimestamp` (string, ISO 8601)

Materializations:
- `votes`: Upsert into this table based on the `voteId`. The fields should be the same as the `event.vote_submitted` event.

### command.solicit_proposal -> event.proposal_solicited

Request a specialist to submit a proposal. See [Specialist Strategies](#specialist-strategies) for resolution and interface details.

API Input:
- `sessionId` (string, UUID)
- `specialistId` (string, UUID)
- `fromTransitionExecutionId` (string, UUID, optional, defaults to the `transitionExecutionId` of the most recent `event.transition_executed` event for the session) - The transition execution ID that represents the state the machine should be in when the specialist makes their proposal.

Stored Command (API input + server-generated):
- `commandCorrelationId` (string, UUID)
- All API input fields
- `receivedAtTimestamp` (string, ISO 8601)

Event Parameters:
- All parameters from the stored command, plus:
- `solicitationId` (string, UUID)
- `solicitedAtTimestamp` (string, ISO 8601)

Materializations:
- `proposal_solicitations`: Upsert into this table based on the `solicitationId`. The fields should be the same as the `event.proposal_solicited` event. This table allows tracking of outstanding proposal requests.

### command.solicit_vote -> event.vote_solicited

Request a specialist to vote on a pair of proposals. See [Specialist Strategies](#specialist-strategies) for resolution details.

API Input:
- `sessionId` (string, UUID)
- `specialistId` (string, UUID)
- `proposalIdA` (string, UUID)
- `proposalIdB` (string, UUID)

Stored Command (API input + server-generated):
- `commandCorrelationId` (string, UUID)
- All API input fields
- `receivedAtTimestamp` (string, ISO 8601)

Event Parameters:
- All parameters from the stored command, plus:
- `solicitationId` (string, UUID)
- `solicitedAtTimestamp` (string, ISO 8601)

Materializations:
- `vote_solicitations`: Upsert into this table based on the `solicitationId`. The fields should be the same as the `event.vote_solicited` event. This table allows tracking of outstanding vote requests.


### command.execute_transition -> event.transition_executed

Execute a transition that changes the state machine that is modelling the session.

> **Note:** Currently, this command only supports the `sheep` session type. Other session types will return a 400 error. This limitation will be removed as additional session types are implemented.

API Input:
- `sessionId` (string, UUID)
- `transitionName` (string)
- `toStateName` (string)
- `toParamsJSONString` (string, optional) - Opaque JSON string containing parameters for the target state. Typically passed through from the winning proposal. The framework stores this value but doesn't interpret its contents.
- `executionSource` (string, enum, [PROPOSAL|MANUAL|OVERRIDE], optional, defaults to MANUAL)
- `proposalId` (string, UUID, optional)

Stored Command (API input + server-generated):
- `commandCorrelationId` (string, UUID)
- All API input fields
- `receivedAtTimestamp` (string, ISO 8601)

Event Parameters:
- All parameters from the stored command, plus:
- `transitionExecutionId` (string, UUID) - Unique identifier for this transition execution.
- `executedAtTimestamp` (string, ISO 8601)

Materializations:
- `transition_executions`: Upsert into this table based on the `transitionExecutionId`. The fields should be the same as the `event.transition_executed` event. This table allows a simple way to represent the current state of the transition execution.

- `sessions`: Update the `currentStateName` and `currentParamsJSONString` to reflect the new state after the transition. 

### command.evaluate_consensus -> event.consensus_evaluated

Evaluate consensus using the registered Arbiter strategy. The framework invokes the arbiter directly (not via solicitation).

**Default Arbiter: weighted ahead-by-k**

- LLMs begin with weight 0.0; humans begin with weight 1.0
- If a human votes, that decision wins immediately
- Otherwise, leading proposal must be ahead by k weighted votes
- Risk dial (state-level config) scales LLM weights

API Input:
- `sessionId` (string, UUID, required)
- `fromTransitionExecutionId` (string, UUID, optional) - Filter proposals/votes to this round

Stored Command (API input + server-generated):
- `commandCorrelationId` (string, UUID)
- All API input fields
- `receivedAtTimestamp` (string, ISO 8601)

Event Parameters:
- All parameters from the stored command, plus:
- `evaluationId` (string, UUID)
- `evaluatedAtTimestamp` (string, ISO 8601)
- `consensusReached` (boolean)
- `winningProposalId` (string, UUID, optional)
- `reasoning` (string)

Materializations:
- No materializations. This command is for triggering arbitration.

### command.register_specialist -> event.specialist_registered

Register an LLM-based specialist for a session type. See [Specialist Strategies](#specialist-strategies) for the strategy interface.

API Input:
- `specialistId` (string) - Unique identifier for this specialist
- `machineName` (string) - Session type this specialist is registered for
- `fromStateName` (string, optional) - If set, specialist is only available in this state. If null/omitted, available in all states.
- `specialistRole` (string, enum, ['proposer'|'voter'|'arbiter'|'tool'])
- `strategyFunctionKey` (string) - Strategy function identifier (e.g., "proposer" loads `./strategies/{machineName}/proposer.ts`)
- `modelId` (string) - Model identifier passed to the strategy
- `displayName` (string) - Human-readable name for UI display
- `weight` (number, default: 1.0) - Voting weight for consensus calculation
- `temperature` (number, default: 0.2) - LLM temperature parameter
- `maxTokens` (number, default: 2000) - LLM max tokens parameter
- `topP` (number, optional) - LLM top_p parameter

Stored Command (API input + server-generated):
- `commandCorrelationId` (string, UUID)
- All API input fields
- `receivedAtTimestamp` (string, ISO 8601)

Event Parameters:
- All parameters from the stored command (with `fromStateName` as nullable), plus:
- `registeredAtTimestamp` (string, ISO 8601)

Validation:
- Strategy file must exist and export a valid strategy interface. Registration fails if validation fails.
- **Model ID Consistency**: If the `specialistId` encodes model parameters (format: `specialist.{sessionType}.{role}.{provider}_{model}_{tier}`), the `modelId` must match what's encoded in the ID. Returns 400 if mismatched.
- **Immutable Fields on Re-registration**: If a specialist with the same `specialistId` already exists:
  - `modelId` cannot be changed (returns 409 Conflict)
  - `strategyFunctionKey` cannot be changed (returns 409 Conflict)
  - Other fields (weight, displayName, temperature, maxTokens, topP) can be updated

Specialist ID Format:
- **Recommended format**: `specialist.{sessionType}.{role}.{provider}_{model}_{tier}`
- Example: `specialist.hanoi.proposer.nvidia_nemotron-3-nano-30b-a3b_free`
- This format encodes model parameters in the ID itself, ensuring each model configuration is a distinct specialist
- The `modelId` field is for convenience; the ID is the source of truth for identity

Test Cases:
- **Positive**: Register new specialist with valid strategy and matching modelId
- **Positive**: Re-register existing specialist with same modelId and strategyFunctionKey (updates other fields)
- **Negative**: Register with mismatched modelId vs encoded specialistId (400)
- **Negative**: Re-register existing specialist with different modelId (409)
- **Negative**: Re-register existing specialist with different strategyFunctionKey (409)

Materializations:
- `specialists`: Upsert into this table based on the `specialistId`. Stores all registration parameters.

### command.adjust_weight -> event.weight_adjusted

Adjust a specialist's voting weight. The weight is scoped to the specialist's `fromStateName` (null = applies to all states).

API Input:
- `specialistId` (string) - The specialist to adjust
- `weight` (number, 0-10) - New weight value

Stored Command (API input + server-generated):
- `commandCorrelationId` (string, UUID)
- All API input fields
- `receivedAtTimestamp` (string, ISO 8601)

Event Parameters:
- `specialistId` (string)
- `commandCorrelationId` (string, UUID)
- `previousWeight` (number)
- `newWeight` (number)
- `adjustedAtTimestamp` (string, ISO 8601)

Materializations:
- `specialists`: Update the `weight` column for the matching `specialistId`.

### command.recalculate_weight -> event.weight_recalculated

Evaluative command that analyzes a specialist's voting history against human votes and recommends a new weight based on alignment. Does NOT mutate state—caller must issue `adjust_weight` separately to apply.

**Default Strategy: Agreement-based**
- Finds vote pairs where specialist and human voted on the same `(proposalIdA, proposalIdB)`
- Calculates agreement rate = matching votes / total comparisons
- Recommended weight = agreement rate (0.0-1.0)

API Input:
- `specialistId` (string) - The specialist to evaluate
- `machineName` (string) - Session type (store) to query
- `maxRounds` (number, optional) - Limit to last N transition rounds
- `maxSeqNum` (number, optional) - Time-travel: only consider events up to this sequence number

Stored Command (API input + server-generated):
- `commandCorrelationId` (string, UUID)
- All API input fields
- `receivedAtTimestamp` (string, ISO 8601)

Event Parameters:
- `recalculationId` (string, UUID)
- `commandCorrelationId` (string, UUID)
- `specialistId` (string)
- `machineName` (string)
- `recalculatedAtTimestamp` (string, ISO 8601)
- `fromStateName` (string, nullable) - The specialist's registered state scope
- `recommendedWeight` (number) - Calculated weight based on alignment
- `currentWeight` (number) - Specialist's current weight
- `agreementRate` (number) - Agreement rate (0.0-1.0)
- `totalComparisons` (number) - Vote pairs compared
- `matchingVotes` (number) - Vote pairs where specialist agreed with human
- `reasoning` (string) - Human-readable explanation

Materializations:
- None. Evaluative command—records the analysis but doesn't update tables.

### command.evaluate_accuracy -> event.accuracy_evaluated

Evaluative command that assesses a specialist's recent performance by comparing their proposals/votes against human decisions across all sessions within a machineName. Does NOT mutate state—the result event is stored in the event stream only.

**For proposers:** Compares the specialist's proposal against the human-endorsed proposal (identified by which proposal the human voter voted for) on three dimensions: transition name, target state, and parameters.

**For voters:** Compares the specialist's voteFor against the human's voteFor on the same proposal pairs. All three match rates equal the vote agreement rate.

Rounds where the human voted NEITHER are excluded (no ground truth). When the human voted BOTH, a proposer matches if their proposal matches either of the two proposals.

API Input:
- `specialistId` (string) - The specialist to evaluate
- `machineName` (string) - Session type (store) to query
- `lookback` (number, optional) - Limit to last N transition rounds
- `maxSeqNum` (number, optional) - Time-travel: only consider events up to this sequence number

Stored Command (API input + server-generated):
- `commandCorrelationId` (string, UUID)
- All API input fields
- `receivedAtTimestamp` (string, ISO 8601)

Event Parameters:
- `evaluationId` (string, UUID)
- `commandCorrelationId` (string, UUID)
- `specialistId` (string)
- `machineName` (string)
- `evaluatedAtTimestamp` (string, ISO 8601)
- `totalRoundsCompared` (number) - Rounds with comparable data (excludes NEITHER)
- `transitionMatchRate` (number, 0.0-1.0) - Proposers: transition name match; Voters: vote agreement
- `stateMatchRate` (number, 0.0-1.0) - Proposers: target state match; Voters: same as transitionMatchRate
- `paramsMatchRate` (number, 0.0-1.0) - Proposers: params match; Voters: same as transitionMatchRate
- `totalCostUSD` (number) - Aggregate cost from specialist events
- `avgCostUSD` (number) - Average cost per round
- `avgLatencyMsec` (number) - Average latency per round
- `totalInputTokens` (number)
- `totalOutputTokens` (number)
- `lookback` (number) - Actual rounds considered
- `reasoning` (string) - Human-readable summary

Materializations:
- None. Evaluative command—records the analysis but doesn't update tables.

---

## Query Endpoints

### GET /specialists

Query registered specialists for a session type.

Query Parameters:
- `storeId` (string, default: 'sheep') - Session type to query
- `fromStateName` (string, optional) - Filter specialists available in this state (includes specialists with `fromStateName: null` which are available in all states)
- `specialistRole` (string, enum, optional) - Filter by role: 'proposer', 'voter', 'arbiter', or 'tool'

Response:
- Array of `SpecialistSummary` objects from the materialized `specialists` table
